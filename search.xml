<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[JavaScript中的内存回收机制]]></title>
    <url>%2FBlog%2F2018%2F11%2F25%2FJavaScript%E4%B8%AD%E7%9A%84%E5%86%85%E5%AD%98%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[一、内存泄漏​ 由于某些原因不再需要的内存没有被操作系统或则空闲内存池回收。编程语言中有多种管理内存的方式。这些方式从不同程度上会减少内存泄漏的几率，高级语言嵌入了一个名为垃圾收集器的软件，其工作是跟踪内存分配和使用，以便找到不再需要分配内存的时间，在这种情况下，它将自动释放它。然而，该过程是近似的，因为知道是否需要某些存储器的一般问题是不可判定的（不能通过算法来解决）。 1.1 循环引用导致的内存泄漏​ 当两个对象相互引用时，会形成一个循环引用，使每个对象的引用计数为1，在纯粹的垃圾收集系统中，循环引用不是问题：如果任何其他对象都不引用所涉及的对象，则两者都是会被视为垃圾而回收。但是，在引用计数系统中，两个对象都不能被销毁，因为引用计数永远不会减到零。在使用垃圾回收和引用计数的混合系统中，由于系统无法识别循环引用而导致泄漏。在这种情况下，DOM对象和Javascript对象都不会被破坏。 12345678910&lt;script type="text/javascript"&gt; document.write("Circular referances between Javascript and DOM!"); var obj; window.onload = function() &#123; obj = document.getElementById("DivElement"); document.getElementById("DivElement").expandoProperty = obj; Array(1000).join(new Array(2000).join("XXXXX")); &#125;&lt;/script&gt;&lt;div id="DivElement"&gt;Div Element&lt;/div&gt; ​ 如上面代码所示，Javascript对象obj引用了DivElement表示的DOM对象。DOM对象反过来又通过expandoProperty对Javascript对象有一个引用。Javascript对象和DOM对象之间存在循环引用。因为DOM对象通过引用计数进行管理，所以两个对象都不会被销毁。 1.2 外部函数引起的循环引用​ 下面代码中，通过调用外部函数myFunction来创建循环引用。Javascript对象和DOM对象之间的循环引用将最终导致内存泄漏。 1234567891011document.write("Circular references between Javascript and DOM!");function myFunction(element) &#123; this.elementReferences = element; //this code forms a circular references here //by DOM--&gt;JS--&gt;DOM element.expandoProperty = this;&#125;function Leak() &#123; //this code will leak; new myFunction(document.getElementById("myDiv"));&#125; ​ 正如上面这两类代码示例所显示的，循环很容易创建。他们还倾向于在Javascript中最方便的编程结构：闭包。 1.3 闭包引起的内存泄漏​ Javascript的优点之一是它允许函数嵌套在其他函数之中，嵌套内部函数可以继承外部函数的参数和变量，并且对该函数是私有的。Javascript开发人员使用内部函数将小效用函数集成到其他函数中，使得内部函数（childFunction）可以访问外部parentFunction的变量。当一个内部函数获取并使用对其外部函数变量的访问时，它称为闭包。 ​ 一个简单的闭包例子 123456789document.write("Closure Demo!");window.onload = function closureDemoParentFunction(paramA)&#123; var a = paramA; return function closureDemoInnerFunction(paramB)&#123; alert(a + " " + paramB); &#125;;&#125;;var x=closureDemoParentFunction("outer x");x("inner x"); ​ 在上面的代码中，closureDemoInnerFunction是父函数closureDemoParentFunction中定义的内部函数。当用外部x的参数对closureDemoParentFunction进行调用时，外部函数变量a被赋值外部x。函数返回一个指向内部函数closureDemoInnerFunction的指针，它包含在变量x中。必须注意的是，外部函数closureDemoParentFunction的局部变量a即使在外部函数返回后也会存在。这与C++等编程语言不同，在函数返回后，局部变量不再存在。在Javascript中，调用closureDemoParentFunction的时刻，创建一个具有属性a的作用域对象。此属性包含paramA的值，也称为”outer x”。同样，当closureDemoParentFunction 返回时，它将返回内部函数closureDemoInnerFunction，它包含在变量x中。 ​ 由于内部函数持有对外部函数的变量的引用，因此具有属性a的作用域对象不会被垃圾回收。当在x上用一个参数值（即x(“inner x”)进行调用时，将弹出一个显示”outer x inner x”的警报。闭包功能强大，因为它们允许内部函数在外部函数返回后保留对外部函数变量的访问权限。遗憾的是，闭包在Javascript对象和DOM对象之间隐藏循环引用非常出色。 ​ 由于IE9之前的版本对Javascript对象和COM对象使用不同的垃圾回收例程，因此闭包在这些版本中会导致一些特殊的问题。具体来说，如果闭包的作用域中保存着一个HTML元素，那么就意味着该元素将无法被销毁。 123456function assignHandler() &#123; var element = document.getElementById("my_btn"); element.onclick = function() &#123; alert(element.id); &#125;;&#125; ​ 以上代码创建了一个作为element元素事件处理程序的闭包，而这个闭包又创建了一个循环引用。由于匿名函数保存了一个对assignHandler()的活动对象的引用，因此就会导致无法减少element的引用数。只要匿名函数存在，element的引用数至少也是1，因此它占用的内存永远也会被回收。不过，这个问题是可以被解决的： 12345678function assignHandler() &#123; var element = document.getElementById("my_btn"); var id = element.id; element.onclick = function() &#123; alert(id); &#125;; element = null;&#125; ​ 上面代码，是把element.id的一个副本保存在一个变量中，并且在闭包中引用该变量消除循环引用，但是，这种程度还不能解决内存泄露的问题。必须要记住：闭包会引用包含函数的整个活动对象，而这其中包含着element。即使闭包不直接引用element，包含函数的活动对象中也仍然会保存着一个引用。因此，必须要把element变量设置为null。这样就能解除对DOM对象的引用，顺利减少引用次数，确保回收其占用的内存。 1.4 事件处理程序引起的内存泄漏​ 在下面的代码中，你将会发现，一个JavaScript对象（obj）包含对DOM对象（由id”元素”引用）的引用的闭包。DOM元素反过来又具有对Javascript obj的引用。在Javascript对象和DOM对象之间产生的循环引用会导致内存泄漏。 1234567891011&lt;script type="text/javascript"&gt; document.write("Program to illustrate memory leak via closure"); window.onload = function outerFunction() &#123; var obj = document.getElementById("element"); obj.onclick = function innerFunction() &#123; alert("Hi!,I will leak"); &#125;; obj.bigString = new Array(1000).join(new Array(2000).join("XXXXX")); &#125;;&lt;/script&gt;&lt;button id="element"&gt;Click Me&lt;/button&gt; 1.5 避免内存泄漏的方法​ 在Javascript中，内存泄露的另一方面是你可以避免它们。当您确定了可以导致循环引用的模式时，正如前面所列举的那样，您可以开始围绕它们进行工作。我们将使用上面三种的事件处理中内存泄漏的方式解决已知内存泄露的方法。一个简单的解决方案是使Javascript对象obj设为null，从而显式中断循环引用。 12345678910111213&lt;script type="text/javascript"&gt; document.write("Avoiding memory leak via closure by breaking the circular reference"); window.onload=function outerFunction()&#123; var obj = document.getElementById("element"); obj.onclick=function innerFunction() &#123; alert("Hi! I have avoided the leak"); // 一些逻辑代码 &#125;; obj.bigString=new Array(1000).join(new Array(2000).join("XXXXX")); obj = null; //显示中断循环引用 &#125;;&lt;/script&gt;&lt;button id="element"&gt;"Click Here"&lt;/button&gt; ​ 另一种方法是通过添加一个闭包，可以避免Javascript对象和DOM对象之间的循环引用。 12345678910111213&lt;script type="text/javascript"&gt; document.write("Avoiding memory leak via closure by adding another closure"); window.onload=function outerFunction()&#123; var anotherObj=function innerFunction() &#123; alert("Hi! I have avoided the leak"); // 一些逻辑代码 &#125;; (function anotherInnerFunction() &#123; var obj = document.getElementById("element"); obj.onclick = anotherObj; &#125;)();&lt;/script&gt;&lt;button id="element"&gt;"Click Here"&lt;/button&gt; ​ 第三种方法可以通过添加一个函数来避免闭包，从而防止泄漏。 1234567891011121314&lt;script type="text/javascript"&gt; document.write("Avoid leaks by avoiding closures!"); window.onload=function() &#123; var obj = document.getElementById("element"); obj.onclick = doesNotLeak; &#125; function doesNotLeak() &#123; //Your Logic here alert("Hi! I have avoided the leak"); &#125;&lt;/script&gt;&lt;button id="element"&gt;"Click Here"&lt;/button&gt; 二、垃圾回收2.1 垃圾收集原理与意义​ 在C和C++之类的语言中，开发人员的一项基本任务就是手动跟踪内存的使用情况，这是造成很多问题的根源。Javascript具有垃圾收集机制，也就是说，执行环境会负责管理代码执行过程中使用的内存。在编写JavaScript程序时，开发人员不再关心内存使用问题，所需内存的分配以及无用内存的回收完全实现了自动管理。这种垃圾收集机制的原理很简单：找出那些不再继续使用的变量，然后释放其占用的内存。为此，垃圾收集器会按照固定时间间隔（或代码执行中预定的收集时间），周期性地执行这一操作。 ​ 局部变量只在函数执行过程中存在。而在这个过程中，会为局部变量在栈（或堆）内存上分配相应的空间，以便存储它们的值。然后在函数中使用这些变量，直至函数执行结束。此时，局部变量就没有存在的必要了，因此可以释放他们的内存以供将来使用。在这种情况下，很容易判断变量是否还有存在的必要；但并非所有情况下就这么容易得出结论。垃圾收集器必须跟踪哪个变量有用哪个变量没用，对于不再有用的对象打上标记，以备将来回收其占用的内存。 2.2 垃圾收集策略​ 现在各大浏览器通常采用的垃圾回收策略有两种：标记清除和引用计数。 2.2.1 标记清除​ JavaScript最常用的垃圾收集方式就是标记清除(mark-and-sweep)。当变量进入环境时，就将该变量标记为”进入环境”。从逻辑上讲，永远不能释放进入环境的变量所占用的内存，因为只要执行流进入到相应的环境，就可能会用到它们。而当变量离开环境时，则将其标记为”离开环境“。 ​ 垃圾收集器在运行的时候会给存储在内存上的所有变量都加上标记。然后，它会去掉环境中的变量以及被环境中的变量引用的变量的标记。而在此之后再被加上标记的变量将被视为准备删除的变量，原因是环境中的变量已经无法访问到这些变量了。最后，垃圾收集器完成内存清除工作，销毁那些带标记的值并回收他们所占用的内存空间。 2.2.2 引用计数​ 这一种垃圾收集策略不太常用，原因在于很容易造成严重的问题：循环引用。引用计数的含义是跟踪记录每个值被引用的次数。当声明了一个变量并将引用类型值赋给该变量时，则这个值得引用次数就是1。如果同一个值又被赋给另一个变量，则该值的引用次数加1。相反如果包含对这个值引用的变量又取到了另外一个值，则这个值的引用次数减1。当这个值的引用次数变成0时，则说明没有办法再访问这个值了，因而就可以将其占用的内存空间回收回来。这样当垃圾收集器下次再运行时，它就会释放那些引用次数为0的值所占用的内存。 ​ 引用计数所带来的严重问题是循环引用。循环引用指的是对象A中包含一个指向对象B的指针，而对象B中也包含一个指向对象A的指针；使得引用次数永远不会变成零，不能被垃圾收集器收集，释放其所占用的内存。 123456function problem() &#123; var objectA = new Object(); var objectB = new Object(); objectA.someOtherObject = objectB; objectB.anotherObject = objectA;&#125; ​ 在上面的例子中，objectA和objectB通过各自的属性相互引用；也就是说，这两个对象的引用次数都是2。在采用标记清除策略的实现中，由于函数执行后，这两个对象都离开了作用域，因此这种相互引用不是个问题。但在采用引用计数策略的实现中，当函数执行完毕后，objectA和objectB还将继续存在，因为它们的引用次数永远不是0。假如这个函数被重复多次调用，就会导致大量的内存得不到回收。 ​ 在IE9之前版本中，有一部分对象并不是原生的Javascript对象。例如，其BOM和DOM中的对象就是使用C++以COM对象的形式实现的，而COM对象的垃圾收集机制采用的就是引用计数策略。因此，即使IE的Javascrip引擎是使用标记清除策略实现的，但Javascript访问的COM对象依然是基于引用计数策略的。 1234var element = document.getElementById("some_element");var myObj =new Object();myObj.element = element;element.someObject = myObj; ​ 上面这个例子中，在一个DOM元素(element)与一个原生JavaScript对象(myObj)之间建立了循环引用。其中，变量myObj有一个名为element的属性指向element；而变量element有一个名为someObject的属性回指到myObj。由于循环引用，即使将例子中的DOM从页面中移除，内存也永远不会回收 。 ​ 为避免这类问题，最好在不使用它们的时候手工断开原生Javascript与DOM元素之间的连接： 12myObject.element = null;element.someObject = null; ​ 将变量设为null意味着切断变量与它之前引用的值之间的连接。当垃圾收集器下次运行的时候，就会删除这些值并回收它们所占用的内存。IE9+把BOM和DOM对象都转换成了真正的Javascript对象。这样就消除了常见的内存泄露现象。 2.3 管理内存2.3.1 触发垃圾收集​ IE的垃圾收集是根据内存分配量进行的，具体就是256个变量、4096个对象（或数组）字面量和数组元素（slot）或则64KB的字符串。达到上述的任何一个临界值，垃圾收集器就会运行。这种实现方式的问题在于，如果一个脚本中包含那么多变量，那么该脚本很可能会在其生命周期中一直保存着那么多的变量。而这样一来，垃圾收集器就不得不频繁地运行，造成严重的性能问题。IE7之后，其Javascript引擎改变了其垃圾收集例程：触发垃圾收集的变量分配、字面量和数组元素的临界值被调整为动态修正。IE7的各项临界初始值和IE6相同，如果垃圾收集例程回收的内存分配量低于15%，这时候把临界条件（变量、字面量、数组元素）加倍，如果例程回收了85%的内存分配量，则将各种临界值重置回默认值。 2.3.2 管理内存​ Javascript在进行内存管理时最主要的问题就是分配给Web浏览器的可用内存量通常要比分配给桌面应的少。这样做的目的是出于安全方面的考虑，目的是防止运行Javascript的网页耗尽全部系统内存而导致系统崩溃。内存限制问题不仅会影响给变量分配的内存，同时还会影响调用栈以及在一个线程中能够同时执行的语句数量。 ​ 因此，确保占有最少的内存可以让页面获得更好的性能。而优化内存占用的最佳方式，就是为执行中的代码只保留必要的数据。一旦数据不再有用，最好通过将其值设置为null来解除其引用。这一做法适用于大多数全局变量和全局对象的属性。局部变量会在它们离开执行环境时自动被解除引用。 1234567function createPerson(name) &#123; var localPerson = new Object(); localPerson.name = name; return localPerson;&#125;var globalPerson = createPerson("Nicholas");globalPerson = null; ​ 在这个例子中，由于localPerson在createPerson()函数执行完毕后就离开了其执行环境，因此无需显示地为它解除引用。但对于全局变量globalPerson，则需要我们在不使用它的时候手工为它解除引用。不过，解除一个值得引用并不意味着自动回收该值所占用的内存。解除引用真正的作用是让值脱离执行环境，以便垃圾收集器下次运行时将其回收。 2.4 减少垃圾收集2.4.1 对象object优化​ 为了最大限度的实现对象的重用，应该像避免使用new语句一样避免使用{}来新建对象。 {&quot;foo&quot; : &quot;bar&quot;}这种方式新建的带属性的对象，常常作为方法的返回值来使用，可是这将会导致过多的内存创建，因此最好的解决办法是：每一次函数调用完成之后，将需要返回的数据放入一个全局的对象中，并返回此全局对象。如果使用这种方式，就意味着每一次方法调用都会导致全局对象内容的修改，这有可能会导致错误的发生。因此，一定要对此全局对象的使用进行详细的注释和说明。 有一种方式能够保证对象（确保对象prototype上没有属性）的重复利用，那就是遍历此对象的所有属性，并逐个删除，最终将对象清理为一个空对象。 cr.wipe(obj)方法就是为此功能而生，代码如下： 123456cr.wipe = function (obj) &#123; for (var p in obj) &#123; if (obj.hasOwnProperty(p)) delete obj[p]; &#125;&#125;; ​ 有些时候，你可以使用cr.wipe(obj)方法清理对象，再为obj添加新的属性，就可以达到重复利用对象的目的。虽然通过清空一个对象来获取“新对象”的做法，比简单的通过{}来创建对象要耗时一些，但是在实时性要求很高的代码中，这一点短暂的时间消耗，将会有效的减少垃圾堆积，并且最终避免垃圾回收暂停，这是非常值得的！ 2.4.2 数组优化​ 将[]赋值给一个数组对象，是清空数组的捷径（例如： arr = [];），但是需要注意的是，这种方式又创建了一个新的空对象，并且将原来的数组对象变成了一小片内存垃圾！实际上，将数组长度赋值为0（arr.length = 0）也能达到清空数组的目的，并且同时能实现数组重用，减少内存垃圾的产生。 2.4.3 function优化​ 方法一般都是在初始化的时候创建，并且此后很少在运行时进行动态内存分配，这就使得导致内存垃圾产生的方法，找起来就不是那么容易了。但是从另一角度来说，这更便于我们寻找了，因为只要是动态创建方法的地方，就有可能产生内存垃圾。例如：将方法作为返回值，就是一个动态创建方法的实例。 123456setTimeout( (function(self) &#123; return function () &#123; self.tick(); &#125;;&#125;)(this), 100) 每过100毫秒调用一次this.tick()，看似没什么问题，但是仔细一琢磨，每一次调用都返回了一个新的方法对象，这就导致了大量的方法对象垃圾！ 为了解决这个问题，可以将作为返回值的方法保存起来，例如： 12345678this.tickFunc = ( function(self) &#123; return function() &#123; self.tick(); &#125;; &#125;)(this);setTimeout(this.tickFunc, 100); Reference：分别于2018.07.07，2018.07.08 发布于博客园-垃圾收集、内存泄漏https://developer.mozilla.org/en-US/docs/Web/JavaScript/Memory_Management#Release_when_the_memory_is_not_needed_anymorehttps://www.cnblogs.com/zhwl/p/4664604.htmlhttp://www.ruanyifeng.com/blog/2017/04/memory-leak.html]]></content>
      <tags>
        <tag>Web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[跨域问题总结]]></title>
    <url>%2FBlog%2F2018%2F11%2F25%2F%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[一、同源与同源策略​ 我们知道，同源指的是协议、域名、端口号全部相同。同源策略(Same Origin Policy)是一种约定，它是浏览器最核心也是最基本的安全功能，如果缺少了同源策略，则浏览器的正常功能都可能会受到影响。Web是构建在同源策略基础之上的，浏览器只是针对同源策略的一种实现。同源策略是处于对用户安全的考量的，如果缺少了同源的限制，那又怎么能够确定别人的网站始终对你是友好的呢。针对非同源的情况制定了一些限制条件： 无法读取不同源的Cookie、LocalStorage、indexDB。 无法获得不同源的DOM。 不能向不同源的服务器发送Ajax请求。 在浏览器中，&lt;script&gt;、&lt;img&gt;、&lt;iframe&gt;、&lt;link&gt;等标签都可以跨域加载资源，而且不受同源策略的限制。事实上，在大多数情境下，我们经常是需要借用非同源来提供数据的，所以这就要用到跨域方面的技术了。 二、JSONP​ JSONP是指JSON Padding，JSONP是一种非官方跨域数据交换协议，由于script的src属性可以跨域请求，所以JSONP利用的就是浏览器的这个原理，需要通信时，动态插入一个javascript标签。请求的地址一般带有一个callback参数，假设需要请求的地址为http://localhost:3000?callback=show，服务器返回的代码一般是show()的JSON数据，而show函数恰恰是前端需要用的这个数据的函数。JSONP非常简单易用，自动补全API利用的就是JSONP。 ​ 一个简单的例子： 12345678var script = doxument.createElement("script");script.setAttribute("type", "text/javascript");script.src="http://example.com/ip?callback=handleResponse";document.body.appendChild(script);function handleResponse(data) &#123; console.log('Your public IP address is: '+data.ip);&#125; ​ JSONP解决跨域的本质：&lt;script&gt;标签可以请求不同域名下的资源，即&lt;script&gt;请求不受浏览器同源策略的影响。上例中的script会向http://example.com/服务器发送请求，这个请求的url后面带了个callback参数，是用来告诉服务器回调方法的方法名的。因为服务器收到请求后，会把相应的数据写进handleResponse的参数，也就是服务器会返回如下的脚本： 123handleResponse(&#123; "ip" : "8.8.8.8"&#125;); ​ 这样浏览器通过&lt;script&gt;下载的资源就是上面的脚本了，&lt;script&gt;下载完就会立即执行，也就是说http://example.com/ip?callback=handleResponse这个请求返回后就会立即执行上面的脚本代码，而这个脚本代码就是调用回调方法和拿到Json数据了。 ​ 我们再来看一个例子： 1234567891011//请求代码function jsonp(callback) &#123; var script = document.createElement("script"); url = `https://localhost:3000?callback=$&#123;callback&#125;`; script.setAttribute("src", url); document.querySelector("head").appendChild(script);&#125;function show(data) &#123; concole.log(`学生姓名为: $&#123;data.name&#125;，年龄为: $&#123;data.age&#125;，性别为: $&#123;data.sex&#125;`);&#125;jsonp("show"); 1234567891011//响应代码const student = &#123; name: "Knight", age: 19, sex: "male"&#125;;var callback = url.parse(req.url, true).query.callback;res.writeHead(200,&#123; "Content-Type": "application/json;charset=utf-8"&#125;);res.end(`$&#123;callback&#125;($&#123;JSON.stringify(student)&#125;)`); JSONP有一个很大问题，就是只能进行GET请求。 {: .notice} 三、跨域源资源共享(CORS) CORS是W3C制定的跨站资源分享标准，可以让AJAX实现跨域访问，定义了在必须访问跨域资源时浏览器与服务器该如何沟通。CORS背后的基本思想，就是使用自定义的HTTP头部让浏览器和服务器进行沟通，从而决定请求或响应应该成功还是失败。 ​ 比如一个简单的使用GET或POST的请求，它没有自定义的头部，而主体内容是text/plain。在发送该请求时，需要给它附加一个额外的Origin头部，其中包含请求页面的源信息（协议、域名、端口号），以便服务器根据该头部信息来决定是否给予响应。 1Origin: http://www.example.com 如果服务器认为这个请求可以接受，就在Access-Control-Allow-Origin头部中发回相同的源信息（如果是公共资源，可以发“*”）。例如： 1Access-Control-Allow-Origin: http://www.example.com 如果没有这个头部信息或信息不匹配，浏览器就会驳回请求。正常情况下，浏览器会处理请求。此时，请求和响应都不包含Cookie信息。 简单请求的跨域： 请求方式为GET或则POST； 假若请求是POST的话，Content-Type必须为下列之一： application/x-www-form-urlencodedmutipart/form-datatext/plain 不含有自定义头； 对于简单的跨域只进行一次http请求： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253function ajaxPost(url, obj, header) &#123; return new Promise((resolve, reject) =&gt; &#123; var xhr=new XMLHttpRequest(), str = '' ; keys = Object.keys(obj); for(var i=0,len=keys.length;i&lt;len;i++) &#123; str +=`$&#123;keys[i]&#125;=$&#123;obj[keys[i]]&#125;&amp;`; &#125; str = str.substring(0, str.length - 1); xhr.open('post', url); xhr.setRequestHeader("Content-Type", "application/x-www-form-urlencoded"); if(header instanceof Object) &#123; for(var k in header) xhr.setRequestHeader(k, header[k]); &#125; xhr.send(str); xhr.onreadystatechange = function() &#123; if(xhr.readyState == 4) &#123; if(xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300 || xhr.status == 304) &#123; resolve(xhr.responseText); &#125; else &#123; reject(); &#125; &#125; &#125; &#125;);&#125;ajaxPost("https://localhost:3000?page=cors", &#123; name: "Knight", age: 19, sex: "male"&#125;).then((text) =&gt; &#123;console.log(text);&#125;, ()=&gt;&#123;console.log("请求失败");&#125;);//后端处理var postData = "";req.on("data", (data) =&gt; &#123; postData += data;&#125;);req.on("end", () =&gt; &#123; postData = querystring.parse(postData); res.writeHead(200, &#123; "Access-Control-Allow-Origin": "*", "Content-Type": "application/json;charset=utf-8" &#125;); if(postData.name === student.name &amp;&amp; Number(postData.age) === student.age &amp;&amp; postData.sex === student.sex) &#123; res.end(`yeah! $&#123;postData.name&#125; is a good guy!`); &#125; else &#123; res.end("No! a bad guy!"); &#125;&#125;); 对于非简单请求来说，需要两次http请求，其中在请求之前有一次预检请求。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263function ajaxPost(url, obj, header) &#123; return new Promise((resolve, reject) =&gt; &#123; var xhr=new XMLHttpRequest(), str = '' ; keys = Object.keys(obj); for(var i=0,len=keys.length;i&lt;len;i++) &#123; str +=`$&#123;keys[i]&#125;=$&#123;obj[keys[i]]&#125;&amp;`; &#125; str = str.substring(0, str.length - 1); xhr.open('post', url); xhr.setRequestHeader("Content-Type", "application/x-www-form-urlencoded"); if(header instanceof Object) &#123; for(var k in header) xhr.setRequestHeader(k, header[k]); &#125; xhr.send(str); xhr.onreadystatechange = function() &#123; if(xhr.readyState == 4) &#123; if(xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300 || xhr.status == 304) &#123; resolve(xhr.responseText); &#125; else &#123; reject(); &#125; &#125; &#125; &#125;);&#125;ajaxPost("https://localhost:3000?page=cors", &#123; name: "Knight", age: 19, sex: "male"&#125;, &#123;"X-author": "Knight"&#125;).then((text) =&gt; &#123;console.log(text);&#125;, ()=&gt;&#123;console.log("Request Error!");&#125;);//后端处理var postData = "";if(req.method == "OPTIONS") &#123; res.writeHead(200, &#123; "Access-Control-Max-Age": 3000, "Access-Control-Allow-Headers": "X-author", "Access-Control-Allow-Origin": "*", "Content-Type": "application/json;charset=utf-8" &#125;); res.end(); return void 0;&#125;req.on("data", (data) =&gt; &#123; postData += data;&#125;);req.on("end", () =&gt; &#123; postData = querystring.parse(postData); res.writeHead(200, &#123; "Access-Control-Allow-Origin": "*", "Content-Type": "application/json;charset=utf-8" &#125;); if(postData.name === student.name &amp;&amp; Number(postData.age) === student.age &amp;&amp; postData.sex === student.sex) &#123; res.end(`yeah! $&#123;postData.name&#125; is a good guy!`); &#125; else &#123; res.end("No! a bad guy!"); &#125;&#125;); 上面代码中，两个响应头: Access-Control-Allow-Headers，用来指明在实际的请求中，可以使用那些自定义的http请求头；Access-Control-Max-Age，用来指定此次预请求的结果的有效期，在有效期内则不会发出预请求，类似于缓存。 四、document.domain实现跨域 可以将子域和主域的document.domain设为同一个主域来实现跨域。但前提条件是，这两个域名必须属于同一个基础域名，所用的协议，端口都要一致，否则无法通过document.domain()来进行跨域。 ​ example 1: ​ 如果想要在你的http://www.knightboy.cn/a.html页面里使用&lt;iframe&gt;调用另一个http://knightboy.cn/b.html页面。这时候你想在a页面里面获取b页面里的DOM，然后进行操作。然后你会发现你不能获得b的DOM。document.getElementById(&quot;myIFrame&quot;).contentWindow.document或window.parent.document.body因为两个窗口不同源而报错。 ​ 这时候你只需要在a页面里和b页面里把document.domain设置成相同的值就可以在两个页面里操作DOM了。 ​ example 2: ​ 如果你在http://www.knightboy.cn/a.html页面里写入了document.cookie = &quot;key=hello world&quot;；你在http://knightboy.cn/b.html页面是拿不到这个cookie的。 ​ 原因在于，Cookie是服务器写入浏览器的一小段信息，只有同源的网页才能共享。但是，两个网页一级域名相同，二级域名不同，浏览器允许通过设置document.domain来共享Cookie。另外，服务器也可以在设置Cookie的时候，指定Cookie的所属域名为一级域名。这样的话，二级域名和三级域名不用做任何设置便可以读取这个Cookie。 ​ 有一点需要注意的是：document.domain虽然可以读写，但只能设置成自身或者是高一级的父域且主域必须相同。所以只能解决一级域名相同二级域名不同的跨域问题。还有就是document.domain只适用于Cookie和iframe窗口，LocalStorage和IndexDB无法通过这种方法跨域。 五、window.name跨域​ window对象有一个name属性，该属性有个特征：即在一个窗口(window)的生命周期内，窗口载入的所有页面都是共享一个window.name的，每个页面对window.name都有读写的权限，window.name是持久存在一个窗口载入过的所有页面中的，并不会因新页面的载入而进行重置。注意，window.name的值只能是字符串的形式，且这个字符串的大小最大能容许2M左右甚至更大的容量，因浏览器而异，但一般是够用的。 ​ example 1: 现在在一个浏览器的一个标签页里打开http://www.knightboy.cn/a.html页面，你通过location.href = http://baidu.com/b.html，在同一个浏览器标签页里打开了不同域名下的页面。这时候这两个页面你可以使用window.name来传递参数。因为window.name指的是浏览器窗口的名字，只要浏览器窗口相同，那么无论在哪个页面里访问都是一样的。 ​ example 2: 你的http://www.knightboy.cn/a.html页面里使用&lt;iframe&gt;调用另一个http://baidu.com/b.html页面。这时候你想在a页面里获取b页面里的DOM，然后进行操作。结果会发现不能获得b中的DOM。同样会因为不同源而报错，和上面提到的不同之处就是两个页面的一级域名也不相同。这时候document.domain就解决不了了。 ​ 浏览器窗口有window.name属性。这个属性的最大特点就是，无论是否同源，只要在同一个窗口里，前一个网页设置了这个属性，后一个网页可以读取它。比如当在b页面里设定window.name=&quot;hello&quot;，你再返回到a页面，在a页面访问window.name，可以得到hello。这种方法的优点是，window.name容量很大，可以放置非常长的字符串；缺点是必须监听子窗口window.name属性的变化，影响网页性能。 12345678910111213141516171819202122232425&lt;!--a.html--&gt;&lt;DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;跨域&lt;/title&gt; &lt;script&gt; function getData() &#123;//iframe载入后执行该函数 var iframe = document.getElementById("proxy"); iframe.onload=function() &#123;//a.html与iframe属于同源了,可以互相访问 var data = iframe.contentWindow.name; //获取iframe里的window.name，也就是b.html页面给它设置的数据 alert(data); &#125; iframe.src="data.html";//这里的data.html为随便的一个页面， //目的是，使得a.html能访问到iframe里的内容， //也可设置成about:blank &lt;/script&gt; &lt;head&gt;&lt;body&gt; &lt;iframe id="proxy" src="http://baidu.com/b.html" style="display:none" onload="getData()"&gt; &lt;/iframe&gt;&lt;/body&gt;&lt;/html&gt; 1234&lt;!--b.html--&gt;&lt;script&gt; window.name="this is some data you got from b.html";&lt;/script&gt; 六、window.postMessage方法跨域 window.postMessage是一个安全的跨源通信方法。一般情况下，当且仅当执行脚本的页面使用相同的协议（通常都是http）、相同的端口（http默认80，https默认443）和相同的host(两个页面的document.domain的值相同)时，才允许不同页面上的脚本互相访问。window.postMessage提供了一个可控的机制来安全地绕过这一限制，当其在正确使用的情况下。window.postMessage解决的不是浏览器与服务器之间的交互，解决的是浏览器不同窗口之间的通信问题，可以做的就是同步两个网页，当然这两个网页需要属于同一个基础域名。 example 1: 在a页面打开了一个不同源的b页面，你想要让a和b这两个页面互相通信，例如，a要访问b的LocalStorage。又或者，a页面里的iframe的src是不同源的b页面，你想要让a和b两个页面互相通信，比如依旧是想通过a访问b的LocalStorage。 此时的解决办法是：利用HTML5中新增的跨文档通信API，这个API为window对象新增了一个window.postMessage方法，允许跨窗口通信，不论这两个窗口是否同源。a就可以把它的Local Storage发给b，反之，依然可行。 window.postMessage(message, targetOrigin, [transfer])三个参数分别表示为： message是向目标窗口发送的数据； targetOrigin属性来指定哪些窗口能收到消息事件，其值可以是字符串“*”（表示无限制）或者一个URI（或者说是发送消息的目标域名）； transfer可选参数，是一串和message同时传递的Transferable对象，这些对象的所有权将被转移给消息的接收方，而发送一方将不再保有所有权。 另外就是，消息的接收方必须有监听事件，否则发送消息时就会报错。 window.addEventListener(“message”, onmessage); onmessage接收到的message事件包含三个属性： data: 从其他window中传递过来的数据。 origin: 调用postMessage时消息发送窗口的origin。这个origin不能保证是该窗口的当前或未来origin，因为postMessage被调用后可能被导航到不同的位置。 source: 对发送消息的窗口对象的引用；您可以使用此来在具有不同origin的两个窗口间建立双向通信。 123//在a页面执行var popUp = window.open('http://localhost:3000', 'title');popUp.postMessage('Hello World!', 'http://localhost:3000'); 同时在http://localhost:3000的页面里监听message事件： 12345678910window.onload = function() &#123; window.addEventListener('message', onmessage);&#125;function onmessage(event) &#123; if(event.origin == 'http://localhost:8080') &#123;//"发送方a的域名" console.log(event.data);//"Hello World!" &#125; else &#123; console.log(event.data);//"Hello World!" &#125;&#125; 我们来看另外一个例子： 123456789101112131415//发送端代码var domain = "https://localhost", index = 1, target = window.open(`$&#123;domain&#125;/postmesssage-target.html`);function send() &#123; setInterval(() =&gt; &#123; target.postMessage(`第$&#123;index++&#125;次数据发送`, domain); &#125;, 1000);&#125;window.addEventListener("message", (e)=&gt;&#123; if(e.data === 'ok') send(); else console.log(e.data);&#125;); 123456789101112131415161718//接收端代码&lt;head&gt; &lt;script&gt; opener.postMessage("ok", opener.domain); &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;p id = "test"&gt;&lt;/p&gt;&lt;script&gt; var test = document.querySelector("#test"); window.addEventListener("message", (e)=&gt;&#123; if(e.origin !== "http://localhost") &#123; return void 0; &#125; test.innerText = e.data; &#125;);&lt;/script&gt;&lt;/body&gt; 上面页面中，接受页面已经加载了，这时发送一个消息给发送端，发送端再开始向接收端发送数据。 七、片段识别符实现跨域 片段识别符就是指URL的#号后面的部分。比如，http://example.com/x.html#fragment的#fragment。如果只是改变片段标识符，页面不会重复刷新。父窗口和iframe的子窗口之间的通讯或者是window.open打开的子窗口之间的通讯。 父窗口可以把信息，写入子窗口的片段标识符。 12var src= originURL + '#' + data;document.getElementById('myIFrame').src = src; 子窗口通过监听hashchange事件得到通知。 12345window.onhashchange = checkMessage;function checkMessage() &#123; var message = window.location.hash; //... &#125; 同样，子窗口也可以改变父窗口的片段标识符。 1parent.location.href = target + '#' + hash; 总之，父窗口改变子窗口的url的#号后面的部分，后者把要传递的的参数写在#后面，子窗口监听window.onhashchange事件，得到通知，读取window.location.hash解析出有用的数据。同时子窗口也可以向父窗口传递数据。 Reference2018.07.14 首次发布于博客园跨域同源政策及其规避方法 跨域解决方案大全 跨域问题汇总]]></content>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浏览器原理]]></title>
    <url>%2FBlog%2F2018%2F11%2F24%2F%E7%AE%80%E8%BF%B0%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[1 浏览器的高级架构​ 浏览器的主要组件是： 用户界面(The user interface)：这包括地址栏，后退/前进按钮，书签菜单等。浏览器的每个部分都显示除了您看到所请求页面的窗口。 浏览器引擎(The browser engine): 在UI和渲染引擎之间进行编组操作。 渲染引擎(The rendering engine)：负责显示请求的内容。例如，如果请求的内容是HTML，则呈现引擎解析HTML和CSS，并在屏幕上显示解析的内容。 网络(Networking)：用于网络调用，例如HTTP请求，在独立于平台的界面后面使用不同平台的不同实现。 UI后端(UI backend)：用于绘制组合框和窗口等基本小部件。此后端公开了一个非平台特定的通用接口。它下面使用操作系统用户界面方法。 JavaScript解释器(Javascript interpreter)。用于解析和执行JavaScript代码。 数据存储(Data storage)。这是一个持久层。浏览器可能需要在本地保存各种数据，例如cookie。浏览器还支持存储机制，例如localStorage，IndexedDB，WebSQL和FileSystem。 图0 浏览器组件 2 渲染引擎​ 不同的浏览器使用不同的渲染引擎：Internet Explorer使用Trident，Firefox使用Gecko，Safari使用WebKit。Chrome和Opera（来自15版）使用Blink，一个WebKit的分支。 ​ WebKit是一个开源渲染引擎，起初是Linux平台的引擎，并由Apple修改以支持Mac和Windows。有关详细信息，请参阅webkit.org。 3 主流程(The main flow)​ 渲染引擎首先通过网络获得所请求文档的内容，通常以8K分块的方式完成。渲染引擎在获取内容后的基本流程如下： ​ 解析html用以构建DOM树，然后构建Render树(呈现树)，接着布局Render树，最后绘制Render树。流程如图1所示。 图1 渲染引擎基本流程 首先渲染引擎开始解析html文件，并将html标签转化为内容树中的DOM节点。接着，它解析外部CSS文件及Style标签中的样式信息。这些样式信息以及html中的可见性指令将被用来构建另一棵树-Render树。 Render树由一些包含有颜色和大小等属性的矩形区域块组成，它们将被按照正确的顺序显示到屏幕上。 Render树构建好了之后，将会执行Render树布局，它将确定每个节点在屏幕上的确切坐标。再下一步就是绘制，即遍历Render树，并使用UI后端层绘制每个节点。 值得注意的是，这个过程是逐步完成的，为了更好的用户体验，渲染引擎将会尽可能早的将内容呈现到屏幕上，并不会等到所有的html都解析完成之后再去构建和布局Render树。它是边解析边显示，解析一部分内容就显示一部分内容，同时，可能还会通过网络下载其余内容。 图2 Webkit引擎渲染主流程 图3 Gecko引擎渲染主流程 ​ 从图2和图3中可以看出，尽管Webkit和Gecko使用的术语稍有不同，他们的主要流程基本相同。Gecko称可见的格式化元素组成的树为frame树，每个元素都是一个frame，Webkit则使用Render树这个名词来命名由渲染对象组成的树。Webkit中元素的定位称为布局，而Gecko中称为回流。Webkit称利用DOM节点及样式信息去构建Render树的过程为attachment，Geoko在html和DOM树之间附加了一层，这层称为内容接收器，相当制造DOM元素的工厂。 4 浏览器的进程4.1 多进程的浏览器 Browser进程：浏览器的主进程(负责协调、主控)，仅有一个。作用包括： 负责浏览器界面显示，与用户交互。如前进，后退，标签，主页等； 负责各个页面的管理，创建和销毁等其他过程； 将Renderer进程得到的内存中的Bitmap，绘制到用户界面上； 网络资源的管理里，下载等； 第三方插件进程：每种类型的插件对应一个进程，仅当使用该插件时才创建，如通过浏览器的扩展程序，使用PDF查看器插件就能显示PDF文档。 GPU进程：最多一个，用于3D绘制等。 浏览器渲染进程(浏览器内核，Render进程，内部是多线程)：默认每个Tab页面一个进程，互不影响，主要作用是页面渲染，脚本执行，事件处理等(浏览器也会做些优化，把多个空白Tab页合并成一个进程)。 优势： 避免单个page crash影响到整个浏览器的运行 避免第三方插件crash影响到真个浏览器 多进程充分利用多核优势 方便使用沙盒模型隔离插件等过程，提高浏览器的生存能力 * 注意：这样做会带来内存的不小消耗，但从长远来看，在浏览器中用空间换时间的策略还是值得的。 4.2 浏览器内核 GUI渲染线程 负责渲染浏览器界面，解析HTML，CSS，构建DOM树和呈现树(Render tree)，布局呈现树和绘制呈现树。 当界面需要重绘(Repaint)或由于某种操作发生回流(Reflow)时，该线程就会执行。 注意：GUI渲染线程与JS引擎线程是互斥的，当JS引擎执行时GUI线程就会被挂起(Pending)，GUI更新会被保存在一个队列中等到JS空闲时立即被执行。 JS引擎线程 JS引擎线程也称JS内核，负责处理Javascript脚本程序(V8引擎)。 JS引擎线程负责解析Javascript脚本，运行代码。 JS引擎一直等待任务队列中任务的回调过程，并加以处理，一个Tab页中有且仅有一个JS线程在运行JS程序。 注意：GUI渲染线程与JS引擎线程是互斥的，所以如果JS执行时间太长，就会导致页面渲染不连贯，导致页面渲染加载阻塞。(比如在本站打开文章“优化网站性能的35条规则“时偶尔会出现此类情况”)。 事件触发线程 归属于浏览器而不是JS引擎，用来控制事件循环。 当JS引擎执行代码块setTimeout时(也可以来自浏览器内核的其它线程，如鼠标点击、AJax异步请求等)，会将对应任务添加到事件线程中。 当对应的事件符合触发条件时，该线程会把事件添加到任务队列尾，等待着JS引擎空闲。 注意：由于JS单线程的关系，所以在处理任务队列中的任务时必须在JS引擎空闲时按照队列中先后顺序依此执行。 定时触发线程 即是setTimeout和setInterval所在的线程。 浏览器定时计数器并不是由Javascript引擎计数的(因为Javascript引擎是单线程的，处于阻塞状态会影响计时器的准确性)。 因此通过单独的线程来计时并触发定时(计时完毕后，添加到事件队列中，等待JS引擎空闲时执行)。 注意：W3C在HTML标准中规定，规定要求setTimeout中低于4ms的时间间隔算作4ms。 异步http请求线程 在XMLHttpRequest在连接后是通过浏览器新开的一个线程请求 将检测到状态变更时，如果设置有回调函数，异步线程就产生状态变更事件，将这个回调再放入事件队列中。再由JavaScript引擎执行。 5 Reference浏览器的工作原理：新式网络浏览器幕后揭秘 从浏览器多进程到JS单线程，JS运行机制 如何由一道题完善自己的前端知识体系]]></content>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[First]]></title>
    <url>%2FBlog%2F2018%2F11%2F22%2FFirst%2F</url>
    <content type="text"><![CDATA[3 零件模型的特征分析3.0 引言​ 回转类零件按照加工类型将其特征分为外环槽、外倒角、径向孔、齿轮和外螺纹等基本几何特征类型。（简单非回转零件按照加工类型将其特征分为端面、凹槽、通槽、孔、倒角和导圆等基本几何特征类型）由零件几何形状及所对应的加工方法，可以把零件的形状特征分成主特征和辅助特征。对于回转类零件来说，同样可以将其分为主特征和辅助特征。图 3-1 表示出了回转类零件的加工特征类型。当然，分类方式不是唯一的，其中有文献中是从回转类机械零件的设计、工艺角度，也就是从零件的功能、结构组成特点和零件的加工方式来定义特征体素，回转类零件可以分为外部特征、内部特征、孔系特征。外部特征和内部特征又分为两大类： 回转面类和非回转面类。回转面类外部特征可分为圆柱体素、圆锥体素、空刀体素、螺纹体素、圆柱齿轮体素、圆锥齿轮体素、链轮体素、皮带轮体素等。回转面类内部特征分为圆柱体素、圆锥体素、螺纹体素、内平键体素、内花键体素、外平键体素、外平键槽体素、端环槽体素等。非回转面类则是一个由一组特征尺寸约束的2D截面的平移扫描体。孔系特征都是回转面类，可分为光孔体素，沉孔体素、螺纹孔体素、螺钉孔体素、销孔体素等[^ 张应中]。 3.1 零件的拓扑图表达3.1.1 特征的定义与分类 定义 ​ 特征是零件表面上具有一定形状的部分区域，代表零件的某种功能或制造方法^ 基于MBD的零件数字化工艺设计技术。一个零件在形状上是有一定数量的体积形状特征组成的，特征是零件上具有工程意义的一个实体部分。原则上一个具体特征是研究人员根据具体需要定义的，但从便于标准化和便于进行工艺设计系统的算法研究的角度，集成CAD与工艺设计系统必须识别出CAD模型中具有工程意义的制造特征，而特征识别即是对零件实体模型进行解释。 ​ 由于从不同的应用领域来认识特征和提取特征，因此出现了特征的不同定义方式[^ 童秉枢]。例如从设计角度，往往将特征与产品设计知识表示和功能要求相连，把特征定义为：“具有一定形状的实体，与一个或多个设计功能相关，可以作为基本单元进行设计和处理”。如果从制造角度，往往将特征与工艺过程设计、数控编程、自动检测相连，把特征定义为：“对应一定基本加工操作的几何形体”。在文献[^ 童秉枢]中，作者认为，为了在实践中尽可能将设计特征与制造特征统一起来。“特征是零件或部件上一组相关联的具有特定形状和属性的几何实体，有着特定的设计或制造意义。 分类 与特征定义一样，也依赖于应用领域及零部件类型。目前特征的分类也多以形状为主。具体分类形式如图2-1，2-2，2-3所示[^ 童秉枢]。 按几何构型的形状特征分类（如图 2-1 所示） 图2-1 按几何构型的形状特征分类 按类特征的形状特征分类（如图 2-2 所示） 图2-2 按类特征的特征分类 Creo中的形状特征分类 ​ Pro/E是典型的特征造型系统，其中形状特征的分类面向较宽的应用领域，有一定的通用性，分以下几类特征。 ​ 实体特征(solid feature) ：实体特征分为基础特征和工程特征（也称辅助特征）两类，如图 2-3 所示。基础特征用来构建物体的基本形状，然后在其上添加各种工程特征，形成最终模型。 ​ 基准特征(daturn feature)：有基准面、基准轴、基准点、基准曲线和基准坐标系。基准面用于确定草绘平面、视图定位和特征定位时作为参照平面。基准轴在同轴放置或创建径向阵列时用于参照。基准点用于构建基准平面、基准轴与基准曲线等。基准曲线用于创建二维剖面、扫描特征的轨迹线及构建曲面特征的边线等。 ​ 曲面特征(surface feature)：用于创建各种复杂的曲面，可分为拉伸曲面、旋转曲面、扫描曲面、混合曲面和螺旋扫描曲面等。 ​ 修饰特征(cosmetic)：如喷印、螺纹等。 ​ 用户定义的特征(UDF)：这类特征由用户自定义，或来自特征库。 图 2-3 实体特征 广义特征分类 机械产品加工特征分类，可分为五类特征，其中包括形状特征、材料特征、精度特征、制造资源特征[^胡文伟]。 图 2-4 特征分类 ​ 形状特征描述产品的几何形状、尺寸和其他相关信息；材料特征指与零件材料特性和热处理工艺方面的内容；精度特征描述零件的尺寸公差、形位公差及表面粗糙度等京都信息；工艺特征指在加工过程中指导生产的的加工工艺规划的相关信息；制造特征描述生产加工过程中所需要的制造资源情况。 3.1.2 几种拓扑结构图 边的凸性(convexity) ​ ACIS系统中中将边的凸性分为10种类型，分别用值0-9分别表示为未定义凸性(undefined convexity)、凸混合(convex blend)、凹边(concave)、光滑凸起(smooth convex)、光滑凹陷(smooth concave)、光滑(smooth)、凸尖(convex cusp)、凹尖(concave cusp)、尖(cusp)、未设置(unset)这十种类型。表3-1中列出了几种常见的边类型。 表 3-1 边的凸性 序号 举例 凸性(convexity) 1 convex blend 2 concave 3 smooth convex 4 smooth concave 5 smooth 图 3-1 边的凸性 凸凹性判定方式 ​ 对直线边，假设两平面$$f_1$$，$$f_2$$相交于边$$e$$，两平面的法矢分别为$$n_1$$，$$n_2$$，任选一面作为基准面，假如$$f_1$$作为基准面，则通过右手螺旋定则确定相交边$$e$$的方向向量为$$n_e$$ ，则令面$$f_2$$的切向量$$n_t=n_e × n_1$$，则$$ n_1 $$和$$ n_t $$之间的夹角为$$θ$$，若满足$$\begin{vmatrix}θ\end{vmatrix}&lt;\frac{π}{2}$$时，$$e$$为凹边，当$$\frac π 2&lt;θ&lt;\frac{3π}{2}$$时，$$e$$为凸边，$$\begin{vmatrix}θ\end{vmatrix}=\frac{π}{2}$$时，$$e$$为切边或尖角边。$$θ+ = \fracπ 2$$时，$$e$$为切边，$$θ- = \fracπ 2$$时，$$e$$为尖角边。如图 3-1(a)所示。 ​ 当两面相交形成平面曲线时，判定方法类似，假设柱面$$f_1$$，平面$$f_2$$相交于边$$e$$，两面的法矢分别为$$n_1$$，$$n_2$$，任选一面作为基准面，假如$$f_1$$作为基准面，则通过右手螺旋定则确定相交边$$e$$的方向向量为$$n_e$$ ，则令面$$f_2$$的径向向量$$n_t=n_e × n_1$$，则$$ n_1 $$和$$ n_t $$之间的夹角为$$θ$$，若满足$$\begin{vmatrix}θ\end{vmatrix}&lt;\frac{π}{2}$$时，$$e$$为凹边，当$$\frac π 2&lt;θ&lt;\frac{3π}{2}$$时，$$e$$为凸边，$$\begin{vmatrix}θ\end{vmatrix}=\frac{π}{2}$$时，$$e$$为切边或尖角边。$$θ+ = \fracπ 2$$时，$$e$$为切边，$$θ- = \fracπ 2$$时，$$e​$$为尖角边。 如图 3-1(b)所示： 图 3-1(a) 直线边 图 3-1(b) 曲线边 属性邻接图(AAG) ​ 在三维几何特征模型中，CAD模型对精度的要求非常严格，一般采用B-Rep模型来表示。如前一章节，B-Rep模型由三种几何信息：点(Point)、线(Curve)、面(Surface)以及三者之间相互联系的拓扑信息共同构成边界表示的基本元素。把零件几何信息与其点线面之间的连接拓扑信息结合起来，就可以很准确的描述出三维实体在空间中的形状、位置以及大小。 ​ 属性邻接图(Attributed Adjacency Grap, AAG)是一种用于描述零件几何拓扑信息的图结构，是特征识别的基础，Joshi和Chang[^ Joshi]率先提出将零件特征都用AAG来表达，它用无向图来定义一个特征，图结构中包含面(Surface)、边(Edge)、邻接信息(Adjacency Info)和属性信息(Attributed Info)，提出通过特征与零件的AAG图模式匹配来进行特征识别。 ​ 定义为图$$G=&lt;V,E,A&gt;$$，其中$$V$$表示节点的集合，对于零件的每个表面$$f_i$$都有唯一的节点与之对应；$$E$$表示边的集合，对于零件的每两个相邻表面$$f_i,f_j$$都有唯一的连接边与之对应。$$A$$表示特性属性集，和$$E$$中的每一条边$$e_k$$对应，如果$$e_k$$连接的两个面形成凹连接，就用$$ e_k=0 $$表示，用$$ e_k=1 $$表示凸连接。首先用邻接矩阵来表示属性邻接图中面节点和边的拓扑关系，将所有顶点的信息组织成顶点表，利用一个矩阵来表示各顶点之间的邻接关系，然后根据CAD模型的几何拓扑信息，定义相应的面和边的属性，面的属性信息包括面类型、面的方向、凸凹性等，边的属性包括曲线类型、凸凹性等。图3-2表示一个回转类零件CAD模型及其属性邻接图。 图 3-2 简单回转体 图 3-3 属性邻接图 扩展属性邻接图(EAAG) ​ 属性邻接图(Attributed Adjacency Grap, AAG)可以表达特征面的拓扑结构，表示边的凸性，而识别相交特征时仅凭借这些信息是不够充分的。为了有效地进行特征识别，对属性邻接图中的顶点和边进行扩展，采用扩展属性邻接图(Extended Attributed Adjacency Graph, EAAG)来进行描述，但根据不同的应用场景，往往使用不同的扩展属性[^ Gao S M][^ 刘文剑]。零件、毛坯和特征都用EAAG表示，可以很容易从三维模型中B-Reap中得到EAAG图[^ 陶松桥]。 图 3-4 特征子图 加工面邻接图(MFAG) ​ 加工面邻接图(Manufacturing Face Adjacency Graph)是零件的扩展属性邻接图(Extended Attributed Adjacency Graph, EAAG)去除毛坯面或凸壳面后产生的EAAG子图[^ Gao S M]。即是把零件扩展属性邻接图中的权值为$$1$$的边断开后所得到的多个独立的特征子图，这些子图就是加工面邻接图。由于传统机械加工工艺大多都是减材制造，去除毛坯表面多余的材料从而形成加工特征，此时特征面之间的关系体现为凹连接，此时表现为独立的加工特征，可以通过这种方式可以识别零件上相对比较独立的加工特征。但是，当特征之间出现交互时，此时MFAG中将会出现凸连接，该方法对特征的识别不太利好。往往还需要对MFAG图进行分解。如何将含有凸连接的MFAG分解为多个不包含凸连接的MFAG子图。文献[^ 陈永府]中给出了一种分解方式。 最小条件子图(MCSG) ​ 将含有凸连接的MFAG分解成仅含凹连接的所得到的图结构作为最小条件子图(MCSG)[^ Gao S M]。是零件属性邻接图中对应该特征的最大子。由于特征之间存在交互性，使得原有特征遭到破坏，相应的在零件的属性邻接图中原来独立的完整特征也遭到破坏，使得余下特征仅仅是原特征的部分子图。通过最端路线修复被破坏的属性邻接图，从而得到的可以完整表达加工特征的子图称作最小条件子图(MCSG)。 邻接矩阵(Adjacency Matrix) ​ 邻接矩阵是表示顶点之间相邻关系的矩阵。设G=(V,E)是一个图，其中$$V={v_1,v_2,…,v_n} [1] $$ 。G的邻接矩阵是一个具有下列性质的n阶方阵[^ 百度]： 对无向图而言，邻接矩阵一定是对称的，而且主对角线一定为零（在此仅讨论无向简单图），副对角线不一定为0，有向图则不一定如此。 在无向图中，任一顶点i的度为第i列（或第i行）所有非零元素的个数，在有向图中顶点i的出度为第i行所有非零元素的个数，而入度为第i列所有非零元素的个数。 用邻接矩阵法表示图共需要n^2^个空间，由于无向图的邻接矩阵一定具有对称关系，所以扣除对角线为零外，仅需要存储上三角形或下三角形的数据即可，因此仅需要$$\frac{n(n-1)}{2}$$个空间。 在特征识别中，用带权值的无向图表示的邻接图可以用特征矩阵的形式表示。 3.2 回转类零件加工特征3.2.1 典型回转结构​ 回转体零件通常以直线、多段线或曲线作为母线，然后绕一条旋转轴旋转形成的零件，如轴、盘、操作柄、球杆、滑轮、滚轮等。回转类零件一般包含沿轴线分布的构成零件主体的若干特征，这些特征可以细分为基本特征和辅助特征，基本特征是指用于构造零件总体集合结构的特征，如外螺纹、外圆面、外曲面等；附着在基本特征上的特征称为辅助特征，如倒角、环槽、键槽、辅助孔等。 ​ 回转体几何轴线与回转轴线重合，且垂直于回转轴线的横截面均为圆形或环形，或两者的组合带有铸锻或焊接的加强筋轮辐叶片减重孔的零件，例如泵轮风机叶轮等；带有机械加工形成的平面沟槽花键齿形等功能要素的零件，例如齿轮花键轴传动丝杠等；以及起连接紧固作用的螺栓螺母直管接头类零件，如方头螺栓六方螺母等均可作为回转件。除此之外，回转类零件也包括平面、斜面、型面、加强筋、槽腔、开口、孔、下陷、凸台等非回转结构特征。当然，对于以上特征，不是所有的复杂回转类零件都包含这些结构，但一定都包括回转特征和非回转特征。 图3-1 回转体零件的加工特征 3.2.2 回转类零件的结构特点​ 回转体的加工特征很多是机床上加工形成，由车刀的横向和纵向进给来控制车削或铣削进给量，从而控制表面材料的去除量，进而形成回转体加工表面特征。比如，当加工轴时，通过车削或铣削可以形成端面，环面，锥面，柱面，曲面等表面轮廓。进而可以组合形成中心孔、台阶、环槽、退刀槽、越程槽、螺纹、轮齿等特征。以上特征的共性就是轮廓线绕回转轴线生成加工特征。当然，孔特征其中又可以细分成通孔、盲孔、沉头孔、埋头孔。基于回转件是回转特征与非回转特征的综合体，可以把轴套类、盘盖类均视为回转结构。 ​ 轴是组成机械设备的重要零件，它支撑着其它转动体回转并传递扭矩，同时它又通过轴承与机架连接。所有轴上零件都围绕轴心线做回转运动，形成一个以轴为基准的组合体──轴系部件。轴类零件结构组成中具有许多外圆、轴肩、螺纹、螺尾退刀槽、砂轮越程槽和键槽等。外圆用于安装轴承、齿轮、带轮等；轴肩用于轴上零件和轴本身的轴向定位；螺纹用于安装各种锁紧螺母和高速螺母；螺尾退刀槽供加工螺纹时退刀用；砂轮越程槽用于完整磨削出外圆和端面等；键槽用来安装键，以传递扭矩[^ 魏杰]。 ​ 相对而言，套类零件结构较简单。套类零件是机械及传动过程中的重要零件，其结构对功能有着重要影响。套类零件是指回转类零件中的空心薄壁件，是机械加工中广泛应用的一种零件，主要起支撑和导向作用。由于套类零件功用不同，结构和尺寸也千差万别。常见的套类零件有支撑回转轴的各种形式的轴承圈、轴套；夹具上的钻套和导向套；内燃机上的气缸套和液压系统中的液压缸、电液伺服阀的阀套等。 ​ 盘盖类零件是由多个端面、深孔、曲面及外轮廓合成的结构相对复杂的零件，广泛应用于具有支撑和连接作用的场合。在机械零件中占有很大的比重，广泛用于机械设备中，在机械设备的运行中发挥重要作用，不同的盘类零件虽然在尺寸和精度要求方面有所差异，但也有很多的相似之处。盘类零件主要由端面、内孔及外圆等组成，通常盘类零件直径大于其轴向尺寸，长径比较小，比如齿轮、法兰盘及轴承环等。盘类零件主要用于传递动力、转换方向或起轴向定位和密封作用。为加强支撑强度，盘类零件上常设有凸台，凹坑等特征，除此之外，为与其他零件连接，盘类零件上还常设有键槽和各种孔(光孔、沉孔、螺纹孔)等结构[^ 来逢亮]。 图3.2 一般回转特征 图3.3 轴件 图3.4 花键轴 图3.5 盘盖 3.2.3 回转类零件的加工方法​ 复杂回转件通常既具备简单回转特征和非回转特征，往往是二者的综合体。其结构体素和加工方法自然也包含回转件和非回转件的加工方法与加工特征。根据回转类零件的结构特点，主要由零件加工特征来决定相应的加工方法： 孔 ​ 孔特征在任何类型的机械零件上都必不可少，它起着重要的连接、定位、减重、装配作用。根据孔是否贯穿实体将孔分为通孔和盲孔；根据形状又可以分为轴孔、直孔、斜孔；根据孔的用途分为连接孔、导向孔、装配孔、基准孔、工艺孔等类型；孔通常采用钻削加工，精度要求不高。当精度要求高时采用钻、扩、绞的的加工方法；对于较大尺寸孔时常采用镗或铣加工；面对长径比很大的孔，就不得不采用特殊的加工方式，比如用深孔钻来加工此类孔。和外圆相比，孔的加工难度较大，所使用的刀具的直径、长度和安装等都受到被加工孔尺寸的限制。因此，加工同样精度的内孔和外圆时，孔加工比较困难，往往需要较多的工序。孔加工方法较多，常用的有钻孔、扩孔、铰孔、镗孔、拉孔、磨孔、研磨孔、珩磨孔、滚压孔以及各种孔的光整加工和特种加工。 外圆 ​ 作为回转体零件的主要的结构特征，是复杂回转类零件的加工设计基准，一般采取车削的方法，对精度等级要求高时，如液压杆的加工，要采用磨削和超精加工。轴套类、盘类零件是具有外圆表面的典型零件，外圆表面常用的机械加工方法有车削、磨削和各种光整加工。车削加工是外圆表面最经济有效的加工方法，但就其经济精度来说，一般适于作为外圆表面粗加工和半精加工方法；磨削加工是外圆表面主要精加工方法，特别适合各种高硬度和淬火后零件的精加工；光速加工是精加工之后进行的超精密加工方法（如滚压、抛光、研磨等），适用于某些精度和表面质量要求很高的零件。 内圆 ​ 内圆也是回转体零件的主要结构特征之一，通常和外圆同心，对于此类特征，采用钻和镗的方法加工的较多。和外圆加工类似，高精度的内圆可以使用内圆磨削、珩磨和研磨等超精加工方式。 环形槽 ​ 环形槽是位于外圆或内孔之间的环形沟槽，分为退刀槽、越程槽、密封槽等，一般采用车削加工。在车床加工中，如车削内孔或螺纹时，为了便于退出刀具并将工序加工到毛坯底部，常在待加工面末端预先制出方便退刀的空槽，称之为退刀槽[^ 百度学术]。为保证在装配时与相邻零件保证装配准确，在轴肩处应加工出退刀槽。越程槽是在孔的底部加工出的环形沟槽，由于砂轮的回转柱面和端面之间有个圆角，并且这个角度难以精确控制，并且不稳定，在需要磨台阶轴的外径和台阶端面时，侧面与底面夹角处无法磨削到，于是就在外径和台阶相交处将外径和台阶相交处将外径和台阶根部各车去一些，形成一个槽，这就是砂轮越程槽。在车削加工中这种沟槽被称作退刀槽，在磨削加工中叫砂轮越程槽。 螺纹 ​ 根据螺纹类型的不同，主要起着连接、紧固、密封作用。主要采用车削、铣削、攻丝、套丝、磨削、研磨和旋风切削等，复杂零件上的螺纹还可以通过数控铣加工。螺纹滚压是一种无切削螺纹加工工艺，螺纹是靠成形滚压模具是零件毛坯表层产生塑性变形而形成的。螺纹滚压一般在滚丝机、搓丝机或在附装自动开合螺纹滚压头的自动机床上进行，适用于大批量生产标准紧固件的其它螺纹联接件的外螺纹。滚压一般不能加工内螺纹，但对材质较软的工件可以用无槽挤压丝锥冷挤内螺纹，原理和攻丝类似，所需扭矩大但加工精度较之高。 加强筋 ​ 加强筋在盘盖类零件中出现的较多，主要起增加零件的结构强度，提高结构稳定性的作用。回转类零件上的加强筋形状主要是直壁，也有弧形和具有一定角度三维加强筋。可采用3轴、4轴或5轴数控加工，也可采用普通铣床加工。 型腔 ​ 型腔是位于零件非回转区域的槽式结构，又叫凹模，是成型塑件外表面的工作零件，其深度大于零件的过渡角半径。其侧壁有开角、闭角、直角等形式，也有侧壁是凹槽结构。可采用3轴、4轴、5轴数控加工中心加工，也可采用普通铣床加工。 凸台 ​ 对于复杂回转体的凸台多数位于外圆、辐板或加强筋板上，在主体基面上凸起的一部分结构。凸台的主要作用是连接、止动、加强孔边等。凸台的加工方式可采用3轴、4轴、5轴数控加工，同样可采用普通铣床加工。 下陷 ​ 当型腔的深度较小。通常小于或者等于零件的填角半径，所形成的凹陷特征叫做下陷。下陷是盘类零件上常见特征。可采用3轴、4轴、5轴数控加工，也可采用普通铣床加工。 轮齿 ​ 齿轮是机器、仪表中使用最多的重要传动件，齿轮种类很多，齿形形状也各有不同，轮齿是最为复杂的一种加工特征，常用的是渐开线齿形和圆弧齿形，圆弧线齿形又分为单圆弧齿和双圆弧齿两种齿形。齿轮齿形加工分为无屑加工如：冷挤、精锻、轧制等，有屑加工如： 铣齿、拉齿、滚齿、插齿、刨齿、磨齿、剃齿、珩齿等。各种圆柱齿轮和锥齿轮的齿形部分可用切削加工或精密铸造、精密锻造、挤压、粉末冶金等方法制造。齿轮的切削加工按齿形部分的成型方式，有成形法、仿形法和展成法等。 花键 ​ 花键分为内花键和外花键，其按键齿形状又分为矩形花键和渐开线花键。花键是花键轴上的典型回转类零件加工特征。在花键轴中有纵向的键槽，和轴配合的旋转件上对应也有内花键，可保持与轴的同步旋转。起着传递机械扭矩，保证良好的对中性的作用。矩形花键轴应用广泛，渐开线花键轴用于载荷较大的，定心精度要求较高及尺寸较大的连接。矩形花键通常应用于飞机、汽车、拖拉机、机床制造业、农业机械及一般机械传动等装置。由于矩形花键轴多齿工作，承载能力强，对中性和导向性也很好，较浅的齿根可以使应力集中小。其次，花键轴的轴与毂强度削弱小，加工比较方便，用磨削方法可以获得较高的精度。渐开线花键轴用于载荷较大，定心精度要求高，以及尺寸较大的场合。其特点是齿廓为渐开线，受载时齿上有径向力，能起自动定心的作用，使各齿受力均匀，强度高寿命长，加工工艺与齿轮相同，易获得较高精度和互换性[^ 刘志奇]。花键轴的加工工艺方法分为切削加工和塑性成形两大类。塑性成形是通过原材料的塑性变形获得零件的形状，常常在室温条件下采用冷体积成形工艺，直接加工出最终零件。获得齿形的方式有铣齿、刨齿、滚齿、插齿、磨齿等多种加工方式。在渐开线花键轴体积冷精密成形工艺中，已经研究开发出了花键轴冷挤、冷搓、冷打、冷滚压等新工艺[^ Dixit]。 3.3 回转类零件的工程应用​ 在机械制造业中，回转类零件，如： 轴、盘、轮、套、齿轮等占有非常大的比重，这些类中的每一类又可以进一步分成若干子类，如此类推，它们在机械设备中发挥重要作用，可以说，凡是动力传动机构或系统都需要回转件。据统计，在机械设计图样中，回转类零件约占零件总数的70%以上[^ 司尧华]。广泛应用于工业领域、汽车制造领域、航空航天领域、精密机械与仪器等多个领域，发挥不可替代的作用。(随着现代工业的发展，对回转类零件的要求变得更为严格，引进超精密设备固然可以获得一定的加工精度，但同时能够准确描述回转类加工特征信息，也是尤为重要的)。 3.4 加工特征识别分析3.4.1 通用特征的识别分析​ 回转类零件中，通用特征包含过渡特征、通孔、盲孔、复合孔、通槽、平键槽、2D开放型腔、3D型腔、台阶、凸台。这些通用特征不仅广泛用在回转类中，在箱体类、插架类零件中也非常常见，在特征识别技术不断发展的过程中，很多学者对它们进行了较为全面的研究，取得了丰硕的成果。 ​ 对过渡特征来讲，对其进行的特征识别是以复杂零件过渡特征的抑制为目的的。主要是为了简化模型，去除辅助特征，而重点研究主要特征。过渡特征是对应抑制后零件的同一边、点的过渡面的集合。因此过渡特征的识别过程就是对零件中过渡面的组合的过程，它以零件中的所有过渡面及其属性作为输入，输出包含所有过渡特征的动态数组[^ 崔秀芬]。孔特征拓扑结构简单，可识别性高，基于规则和属性邻接图的的方式可以对通孔、盲孔、复合孔进行有效的识别。对于槽特征，其特征都有固定数量与特定位置关系的几何体，由面和边缘组成，其表面类型分为平面，圆柱面、锥面、球面。边的类型有直线、圆弧。表面间的过渡方式分为相切过渡、垂直过渡、角度过渡。通过分析这些几何体数据可以建立起加工特征的知识库。型腔在回转体中较少，但在一些复杂的回转类零件中也会遇到。 图 2.6 开口槽 图 2.7 环槽 图 2.8 通槽 图 台阶 图 孔 图 凸台 ​ 对通用特征的识别，识别某一个特征相对比较容易，我们可以通过图分解和图匹配理论以及基于规则等特征识别方法将该特征识别出来，但当面对的是具体的生产实践时，对特定特征制定的识别规则就很有可能失效或出现识别规则冲突的种种问题。因此，能够对通用特征制定一套统一的识别标准是比较规范的解决方式。本文后面章节将会逐步探讨对通用特征识别研究。 ​ 重点论述各个不同建模工具的几何解析模式（面的表示方式）。。。 3.4.2 固有特征的识别分析​ 回转类零件中，固有特征包括径向孔、中心孔、内外环槽、内外退刀槽、交互环槽、内外花键、内外螺纹、内外齿槽、加强筋等。本文以回转类零件的特征为研究对象，重点研究回转类中最具有代表性的加工特征。其中，回转体中的槽特征最为常见，无论是退刀槽、越程槽还是其它密封槽等特征均具有重要的应用范围。孔特征也是最为常见的特征之一，回转件中，中心孔是在轴的端部，在加工过程中，起轴端支撑的作用。图 2.1是本文主要研究的回转特征。 外花键 内花键 齿轮 内花键 斜齿轮 均布槽 环槽 铣扁 外螺纹 图2-1 回转类特征 3.4.3 交互特征的识别分析​ 当两个独立加工特征之间产生布尔减或布尔增运算时，此时的特征将会呈现某种交互性。出现像面的分割、连接边丢失、连接面丢失、环数增加等问题。这些在交互特征识别时遇到最多。回转件中，交互特征体现在槽之间的交互(图 2.4.1)，孔之间的交互(图 2.4.2)以及孔与槽(图 2.4.3)之间的交互。 图 2.4.1槽-槽 图 2.4.2 槽-孔 图 2.4.3 孔-孔 ​ 前面章节提到，当多个独立特征发生交互时，会使得加工面邻接图出现凸连接，从而部分原有特征会丢失，本来的完整面可能被凸连接分割开来，使特征识别的难度增加。 3.5 本章小结​ 本章通过对零件特征的分析，首先介绍了特征识别时常用到的几种特征拓扑图以及广义的特征定义及分类，然后详细研究了回环类零件的结构特点和加工方法，阐述了不同加工特征的切削加工方法。最后针对本文要研究的回转类零件的加工特征识别方法，对回转类零件通用特征、固有特征及交互特征的特征识别问题进行了大致的分析。 4 回转类零件特征识别算法研究4.0 引言​ 当前机械制造领域，零件的结构复杂程度和对零件特征的加工工艺是处于两端的。也就是说，能够对一个复杂零件做出准确、精细而完整化的工艺表达是现今机械领域的最新要求。机械特征识别技术就是实现该要求的重要方式之一。本章主要以回转类零件为例，分析回转类零件特征识别的算法思维，研究回转类零件的典型加工特征识别方法，提出回转类零件相似性特征识别方法，解决回转类零件以往很少研究的几个加工特征自动识别的问题。 4.1 轴类零件特征识别​ 轴类零件的特征识别通常是基于体分解的方式，通过研究最大切削体的体表示方法来研究轴类的加工特征。本文通过对轴类属性邻接图的二次分解，将轴类特征按照主辅特征分类，然后与建立的特征库进行特征库的匹配，达到识别的目的。如前面章节所述，轴类零件加工特征，既包含回转特征，又包含非回转特征，按照主辅特征的分类方式，可以对轴上特征进行特征分解，将分解后的特征拓扑信息与特征库进行匹配， 匹配成功时记录该特征，失败时，将该特征标记为其它特征，最后输出轴上所有特征的匹配识别结果。 4.1.1 环槽特征识别算法研究​ 首先，分析轴类零件特征-槽特征；尽管槽特征简单，但是由于加工过程的灵活性，再加上为满足不同场合的使用要求或功能而对槽的特征识别带来了很多不确定因素而产生的模糊性识别，以往的特征识别仅仅局限知道该特征是个槽特征，但是至于是什么类型的槽特征就不得而知了。从而把一些重要的属性信息给丢掉了，为简化特征模型带来拓扑信息的不确定性，不利于模型轻量化工艺方法的研究。表4-1总结了典型的九种常见的槽特征类型，并对其定义了唯一的编码标识，能够唯一地定义加工特征类型。 Table 4-1 环槽不同特征类型 编码 名称 槽特征 属性 S0000 矩形环槽 面类型：平面、柱面环数：3 S0001 梯形槽 面类型：平面、锥面、柱面环数：3 S0010 减压槽 面类型：平面、柱面、环面环数：3 S0011 卸载槽 面类型：平面、柱面、锥面、环面环数：3 S0100 U形沟槽 面类型：平面、柱面、环面环数：3 S0101 下凹 面类型：平面、柱面、环面环数：3 S0110 凹陷 面类型：柱面、环面环数：3 S0111 球形端槽 面类型：圆环面环数：3 S1000 密封槽 面类型：平面、柱面、锥面环数：3 ​ 很容易得到，对于环槽这类特征，无论其截面怎么变化，其特征中环的数量始终是3，其特征面可以通过平面、柱面、锥面、环面任意形式的组合而成的。可以为此类特征建立标准化特征库，而后进行加工特征的图匹配，最终识别出该槽特征。对特征编码便于对特征进行惟一性的标识，可以用字母表示主辅特征，用数字号表示该特征下的具体特征，比如用字母S表示槽特征，用二进制编码对每一种具体特征制定序号。分别用S0000、S0001、S0010、S0011、S0100、S0101、S0110、S0111、S1000表示表4-1中的九种特定的环槽特征。类似同样的编码规则，用字母C(chamfer)表示过渡倒角，用字母F(filter)表示过渡圆角，字母B(boss)表示凸台，字母H(hole)表示孔，字母M(main)表示主特征，字母G(gear)表示齿轮示等。 Table 4-2 特征码表 编码序号 B C G F H M S T 0000 凸台 内倒角 直齿外齿 内圆角 通孔 平面 矩形环槽 通槽 0001 外倒角 直齿内齿 外圆角 盲孔 圆柱面 梯形槽 2D型腔 0010 斜齿外齿 螺纹孔 球面 减压槽 开放型腔 0011 斜齿内齿 轴孔 卸载槽 平键槽 0100 阵列孔 U形沟槽 花键槽 0101 样条孔 下凹 外螺纹 0110 径向孔 凹陷 丝杠槽 0111 中心孔 球形端槽 3D型腔 1000 密封槽 ~ ​ 可以说，槽特征是回转类零件中占比很大的一类加工特征。回转类零件中通过去除材料所得的特征在某种程度上均可视为槽特征。毕竟，减材制造在现阶段机械加工领域发展最为完备，再加上大多数回转类零件的毛坯都是棒料，是通过车铣钻磨镗复合加工工艺而得到的零件最终形态。但是，当零件复杂程度高，加工难度大时，特征之间的耦合性将会得到增强，为此，为使特征之间的耦合性更加松散，本文将回转类零件加工特征用特征表的形式定义每一种特征类型，如表 4-2 所示。 12345678910111213141516171819202122232425st=&gt;start: 程序开始e=&gt;end: 程序结束op1=&gt;operation: 模型输入op2=&gt;operation: 沿回转轴线两端遍历特征op3=&gt;operation: 补齐辅助特征op4=&gt;operation: 向列表中添加该特征op5=&gt;operation: 补齐主特征op7=&gt;operation: 识别失败op8=&gt;operation: 定义为其它特征cond=&gt;condition: 是否为辅助特征 ?c1=&gt;condition: 是否为主特征 ?c2=&gt;condition: 是否为最后一个特征 ?io=&gt;inputoutput: export something...|futurest-&gt;op1-&gt;op2-&gt;condcond(yes)-&gt;op3-&gt;op4-&gt;c2cond(no)-&gt;c1c1(yes, top)-&gt;op5-&gt;op4c1(no)-&gt;op7-&gt;op8-&gt;op4c2(yes)-&gt;ec2(no)-&gt;op2 图4.1 轴类零件特征识别算法流程图 4.1.2 齿轮齿槽识别算法研究​ 齿廓特征是机械零部件中最为复杂的形状特征之一，因为涉及曲面加工，由前面章节所讲，生产中最常用的齿轮是渐开线齿轮，尽管渐开线具有较好的几何特性，可以使用滚齿、铣齿、插齿等多种加工方式，但其关键是对刀具的精度要求高，这样才可以使用齿轮范成原理加工出满足精度要求的齿形。归根结底，对齿轮加工特征的识别实际上就是识别加工特征面上的齿间槽特征，并且同一齿轮上的齿特征应该是一模一样的，问题是使用一种算法能够快速并准确识别齿轮上的所有齿槽特征。 ​ 对齿轮齿廓的特征识别研究较少，在参数化建模过程中，对齿的生成是根据齿廓特征参数拉伸生成齿特征。在加工过程中从三维模型中很难获取到加工信息参数，往往从建模工具的参数变量中查找或从二维工程图纸中获取，除此之外，还受到人自身的影响，在大量数据中获取有用信息的过程人是比较容易犯错的，不利于指导加工生产过程。如果能够对齿廓特征进行特征识别，将所需要的加工特征识别出来，实时与人或机器进行交互并输出其工艺信息。这将大大减少零件的废品率，提高加工生产效率，提高MBD工程化应用能力，提升齿轮齿廓加工工艺，简化零件特征描述，缩短三维模型加载所需要的时间。 ​ 首先，获取属性邻接图，通过遍历所有的特征子图，找到能和齿槽特征图相匹配的特征结构。该类特征分解后可以看成由两个渐开线啮合面和一个柱面组成(暂时不考虑过渡特征)，且所有的齿槽特征中的柱面均位于同一个齿底圆上，其半径是确定的，因为该半径是齿底圆半径，所以我们便可以把所有的齿槽组合成一个完整的齿轮齿廓加工特征。具体的算法思想如下： 1234567891011121314151617181920st=&gt;start: 模型导入e=&gt;end: 程序结束op1=&gt;operation: 获取属性邻接图op2=&gt;operation: 获取加工面邻接图op3=&gt;operation: 向容器中添加该特征op4=&gt;operation: 获取最小条件子图op5=&gt;operation: 遍历特征op6=&gt;operation: 定义为其它特征sub1=&gt;subroutine: NEXTc1=&gt;condition: 特征库匹配？c2=&gt;condition: 最后一个特征?c3=&gt;condition: 特征库匹配?io=&gt;inputoutput: 齿廓特征输出st-&gt;op1-&gt;op2-&gt;c1c1(yes,right)-&gt;op3-&gt;c2c1(no)-&gt;op4-&gt;c3c3(yes,left)-&gt;op3c2(yes,left)-&gt;io-&gt;ec2(no)-&gt;sub1(right)-&gt;c1c3(no)-&gt;op6-&gt;op3-&gt;c2 图4.2 齿廓特征识别算法流程图 4.1.3 花键特征识别算法研究​ 在特征识别工程项目中，比较多的加工特征是以一种复制加工特征集的形式出现，即在同一工序中可以直接加工成型的特征，本文把它统一叫做复制加工特征集。对矩形花键，其基面和两侧面的几何关系是相互垂直的，且基面在同一个回转面上。除此之外，把花键特征视作在同一回转面去除表面材料后所得到的沿径向均匀分布的特征。这就和齿轮加工特征有点类似了，花键特征的识别就是要把一组满足特定几何约束和特定形状特征的键槽特征(复制加工特征集)作为一组特征而进行的高效有序的识别过程。 现在有两个问题需要注意： 如何识别不同种类的花键槽。 怎样把多个相同的花键槽统一表示。 如何能够简化特征识别过程，提升该类特征的识别速度。 ​ 针对上面三个问题，本文做了大量的研究。矩形花键和渐开线花键的轮廓是不同的，针对不同类的花键槽，其特征基面组成稍有不同。对矩形花键，其特征基面包括平面和过渡面，参见图4-3[^ 梁旭坤]；对渐开线型花键，特征基面包括二次曲面和过渡面。还有一点至关重要，内外花键的加工特征区别较大，参见图 4-4。 图 4-3 矩形内外花键 图 4-4 渐开线内外花键 图 4-5 矩形花键定心方式 ​ 4.1.4 螺纹特征识别算法研究​ 4.1.5 筋板特征识别算法研究4.2 盘盖类零件特征识别4.2.1 型腔特征识别算法研究4.3 基于混合特征识别的算法实现4.3.14.3.24.3.34.5 本章小结5 系统开发与实现5.0 引言5.1 软件开发平台5.2 特征识别系统5.3 本章小结6 实例测试6.0 引言6.1 轴类零件特征识别实例6.2 盘盖类零件特征识别实例6.3 本章小结7 全文总结与展望致谢参考文献[^ 魏杰]: 魏杰. 机械加工工艺[M].[^ 童秉枢]: 童秉枢. 机械CAD技术基础[M].[^ 胡文伟]: 胡文伟. 特征建模与特征识别及其在CAD/CAPP中的应用[J].[^ 百度学术]: https://baike.baidu.com/item/%E9%80%80%E5%88%80%E6%A7%BD[^ 来逢亮]: 来逢亮. 盘类零件的加工工艺分析[J].[^ 司尧华]: 司尧华. 机械设计图样中回转体类零件基准的选择[J].[^ 刘志奇]: 刘志奇. 花键轴冷滚压成形的分齿条件[J].[^ 崔秀芬]: 崔秀芬. 过渡特征的识别与抑制方法[D].[^ 张应中]: 张应中. 回转类零件特征造型系统[J].[^ Gao S M]: Gao S M, Shah J J. Automatic recognition of interacting machining features based on minimal condition subgraph[J]. Computer-Aided Design, 1998, 30(9): 727-739.[^ 刘文剑]: 刘文剑， 顾琳， 常伟等. 基于属性邻接图的制造特征识别方法[J]. 计算机集成制造系统-CIMS，2001， 7(2):53-58.[^ Joshi]: Joshi S, Chang T C. Graph-based heuristics for recognition of machined features from a 3D solid model[J]. Computer-Aided Design. 1988, 20(2): 58-66.[^ 陈永府]: 陈永府，黄正东，赵建军，龚雄. 基于特征面分割的自动特征识别[J]. 机械设计. 2007, 24(9): 16-17.[^ 百度]: https://baike.baidu.com/item/%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5[^ 陶松桥]: 陶松桥，王书亭，郑坛光，黄正东. 基于非精确匹配的CAD模型搜索方法[J]. 计算机辅助设计与图形学学报. 2010, 22(3): 546-547.[^ Dixit]: U. S. Dixit，P. S. Robi， D. K. Sarma. A systematic procedure for the design of a cold rolling mill. Journal of Materials Processing Technology，2002，121(1): 69-76.[^ 梁旭坤]: http://www.cnnmol.com/Search/ResultView.aspx?conId=avVlw1SInhE%3D]]></content>
      <tags>
        <tag>特征识别</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[优化网站性能的35条规则]]></title>
    <url>%2FBlog%2F2018%2F11%2F17%2F%E4%BC%98%E5%8C%96%E7%BD%91%E7%AB%99%E6%80%A7%E8%83%BD%E7%9A%8435%E6%9D%A1%E8%A7%84%E5%88%99%2F</url>
    <content type="text"><![CDATA[最小化HTTP请求次数​ 最终用户响应时间的80％用于前端。大部分时间都在下载页面中的所有组件：图像，样式表，脚本，Flash等。减少组件数量反过来减少了呈现页面所需的HTTP请求数量。这是更快页面的关键。 减少页面中组件数量的一种方法是简化页面设计。但有没有办法构建内容更丰富的页面，同时还能实现快速响应时间？以下是一些减少HTTP请求数量的技术，同时仍支持丰富的页面设计。 组合文件是一种通过将所有脚本组合到单个脚本中来减少HTTP请求数量的方法，并且类似地将所有CSS组合到单个样式表中。当脚本和样式表在不同页面之间变化时，组合文件更具挑战性，但使这部分发布过程可以缩短响应时间。 CSS Sprites是减少图像请求数量的首选方法。将背景图像合并为单个图像，并使用CSSbackground-image和background-position属性显示所需的图像片段。 ​ 图像地图将多个图像组合成单个图像。整体大小大致相同，但减少HTTP请求的数量会加快页面的速度。图像映射仅在图像在页面中是连续的时才起作用，例如导航栏。定义图像映射的坐标可能是乏味且容易出错的。使用图像地图进行导航也无法访问，因此不建议使用。 内联图像使用data:URL方案将图像数据嵌入实际页面中。这可以增加HTML文档的大小。将内嵌图像组合到（缓存的）样式表中是一种减少HTTP请求并避免增加页面大小的方法。并非所有主流浏览器都支持内嵌图像。 减少页面中HTTP请求的数量是可以开始的地方。这是提高首次访问者性能的最重要指南。正如Tenni Theurer的博客文章浏览器缓存使用 - 暴露！，您网站的每日访问者中有40-60％使用空缓存。让这些首次访问者快速访问页面是获得更好用户体验的关键。 使用内容分发网络（CDN）​ 用户与Web服务器的距离会对响应时间产生影响。在多个地理位置分散的服务器上部署内容将使您的页面从用户的角度加载更快。但是你应该从哪里开始呢？ ​ 作为实现地理位置分散的内容的第一步，请勿尝试重新设计Web应用程序以在分布式体系结构中工作。根据应用程序的不同，更改体系结构可能包括令人生畏的任务，例如同步会话状态和跨服务器位置复制数据库事务。尝试缩短用户与您的内容之间的距离可能会延迟或永远不会通过此应用程序架构步骤。 ​ 请记住，最终用户响应时间的80-90％用于下载页面中的所有组件：图像，样式表，脚本，Flash等。这是性能黄金规则。而不是从重新设计应用程序架构的艰巨任务开始，最好先分散静态内容。这不仅可以缩短响应时间，而且由于内容交付网络，它更容易实现。 内容传送网络（CDN）是分布在多个位置的Web服务器的集合，以更有效地向用户传送内容。选择用于向特定用户传送内容的服务器通常基于网络邻近度的度量。例如，选择具有最少网络跳跃的服务器或具有最快响应时间的服务器。 一些大型互联网公司拥有自己的CDN，但使用CDN服务提供商（如Akamai Technologies，EdgeCast或level3）具有成本效益。对于初创公司和私人网站来说，CDN服务的成本可能过高，但随着您的目标受众变得越来越大并变得更加全球化，CDN对于实现快速响应时间是必要的。在Yahoo！中，将静态内容从其应用程序Web服务器移动到CDN（如上所述的第三方以及Yahoo自己的CDN）的属性将最终用户响应时间提高了20％或更多。切换到CDN是一个相对容易的代码更改，将显著提高您的网站的速度。 添加Expires或Cache-Control标头这条规则有两个方面： 对于静态组件：通过设置远期未来Expires标头实现“永不过期”策略 对于动态组件：使用适当的Cache-Control标头来帮助浏览器处理条件请求 ​ 网页设计越来越丰富，这意味着页面中有更多的脚本，样式表，图像和Flash。您的页面的首次访问者可能必须发出多个HTTP请求，但通过使用Expires标头，您可以使这些组件可缓存。这可以避免后续页面查看中不必要的HTTP请求。Expires头文件通常与图像一起使用，但它们应该用于所有组件，包括脚本，样式表和Flash组件。 ​ 浏览器（和代理）使用缓存来减少HTTP请求的数量和大小，从而加快网页加载速度。Web服务器使用HTTP响应中的Expires头来告诉客户端可以缓存组件多长时间。这是一个遥远的未来Expires标题，告诉浏览器这个响应在2010年4月15日之前不会过时。 1Expires: Thu, 15 Apr 2010 20:00:00 GMT ​ 如果您的服务器是Apache，请使用ExpiresDefault指令设置相对于当前日期的到期日期。ExpiresDefault指令的这个示例将Expires日期设置为距请求时间10年。 1ExpiresDefault "access plus 10 years" ​ 请记住，如果您使用远期的Expires标头，则必须在组件更改时更改组件的文件名。在Yahoo! 我们经常将此步骤作为构建过程的一部分：版本号嵌入在组件的文件名中，例如，yahoo_2.0.6.js。 ​ 使用远期Expires标头仅在用户访问过您的网站后才会影响网页浏览量。当用户第一次访问您的站点并且浏览器的缓存为空时，它对HTTP请求的数量没有影响。因此，此性能改进的影响取决于用户使用已准备好的缓存命中您的页面的频率。（“已准备好的缓存”已包含页面中的所有组件。）我们在Yahoo!上测量了这一点。并发现带有固定缓存的页面查看次数为75-85％。通过使用远期的Expires标头，您可以增加浏览器缓存的组件数量，并在后续页面视图中重复使用，而无需通过用户的Internet连接发送单个字节。 使用Gzip组件​ 通过前端工程师做出的决策，可以显着减少在网络上传输HTTP请求和响应所需的时间。确实，最终用户的带宽速度，互联网服务提供商，与对等交换点的距离等都超出了开发团队的控制范围。但是还有其他变量会影响响应时间。压缩通过减少HTTP响应的大小来减少响应时间。 从HTTP / 1.1开始，Web客户端表示支持使用HTTP请求中的Accept-Encoding标头进行压缩。 1Accept-Encoding: gzip, deflate ​ 如果Web服务器在请求中看到此标头，它可能会使用客户端列出的方法之一压缩响应。Web服务器通过响应中的Content-Encoding标头向Web客户端通知此情况。 1Content-Encoding: gzip ​ Gzip是目前最流行，最有效的压缩方法。它由GNU项目开发，并由RFC 1952标准化。您可能会看到的唯一其他压缩格式是deflate，但效果较差且不太受欢迎。 ​ Gzipping通常将响应大小减少约70％。今天大约90％的互联网流量通过声称支持gzip的浏览器传播。如果你使用Apache，配置gzip的模块取决于你的版本：Apache 1.3使用mod_gzip而Apache 2.x使用mod_deflate。 ​ 浏览器和代理存在已知问题，这些问题可能导致浏览器期望的内容与压缩内容相关的内容不匹配。幸运的是，随着旧浏览器的使用逐渐减少，这些边缘情况正在逐渐减少。Apache模块通过自动添加适当的Vary响应头来提供帮助。 ​ 服务器根据文件类型选择gzip的内容，但通常在他们决定压缩的内容方面受到限制。大多数网站都会gzip他们的HTML文档。gzip你的脚本和样式表也是值得的，但很多网站都错过了这个机会。实际上，压缩包括XML和JSON在内的任何文本响应都是值得的。不应对图像和PDF文件进行gzip压缩，因为它们已经过压缩。试图对它们进行gzip不仅浪费CPU，而且可能会增加文件大小。 ​ 尽可能多地压缩文件类型是减轻页面重量和加速用户体验的简便方法。 将CSS样式表放在头部​ 在研究Yahoo!的性能时，我们发现将样式表移动到文档HEAD会使页面看起来加载速度更快。这是因为将样式表放在HEAD中允许页面逐步呈现。 ​ 关注性能的前端工程师希望页面逐步加载; 也就是说，我们希望浏览器尽快显示它拥有的任何内容。这对于具有大量内容的页面和对较慢Internet连接的用户尤其重要。为用户提供视觉反馈（例如进度指示器）的重要性已得到很好的研究和记录。在我们的例子中，HTML页面是进度指示器！当浏览器逐步加载页面时，标题，导航栏，顶部的徽标等都作为等待页面的用户的视觉反馈。这改善了整体用户体验。 ​ 将样式表放在文档底部附近的问题是它禁止在许多浏览器（包括Internet Explorer）中逐行渲染。这些浏览器会阻止渲染，以避免在样式发生变化时重绘页面元素。用户查看空白页面时卡住了。 ​ HTML规范明确指出，样式表是被包括在网页的HEAD：“与A，[LINK]可以仅出现在一个文档的HEAD部分，尽管它可能出现任意次数”。这些替代品，空白的白色屏幕或无风格内容的闪光都是值得冒险的。最佳解决方案是遵循HTML规范并在文档HEAD中加载样式表。 将JavaScript脚本放在底部​ 脚本引起的问题是它们阻止了并行下载。HTTP / 1.1规范建议的浏览器下载不超过两种组分在每主机名平行。如果您从多个主机名提供图像，则可以并行执行两次以上的下载。但是，在下载脚本时，即使在不同的主机名上，浏览器也不会启动任何其他下载。 ​ 在某些情况下，将脚本移到底部并不容易。例如，如果脚本用于document.write插入页面内容的一部分，则无法在页面中向下移动。可能还存在范围问题。在许多情况下，有办法解决这些问题。 ​ 经常出现的另一种建议是使用延迟脚本。该DEFER属性表明该脚本不包含document.write，并且是浏览器可以继续呈现的线索。不幸的是，Firefox不支持该DEFER属性。在Internet Explorer中，脚本可能会延迟，但不是所需的。如果可以延迟脚本，也可以将其移动到页面底部。这将使您的网页加载速度更快。 避免使用CSS中的expressions​ CSS表达式是一种动态设置CSS属性的强大（且危险）方法。从版本5开始，它们在Internet Explorer中受支持，但从IE8开始不推荐使用。例如，可以使用CSS表达式将背景颜色设置为每小时交替： 1background-color: expression((new Date()).getHours()%2 ? "#B8D4FF" : "#F08A00"); ​ 如此处所示，该expression方法接受JavaScript表达式。CSS属性设置为评估JavaScript表达式的结果。expression其他浏览器会忽略该方法，因此在Internet Explorer中设置属性以在跨浏览器创建一致体验时非常有用。 ​ 表达式的问题在于它们的评估频率高于大多数人的预期。它们不仅在页面呈现和调整大小时进行评估，而且在页面滚动时甚至在用户将鼠标移动到页面上时进行评估。在CSS表达式中添加计数器可以让我们跟踪CSS表达式的计算时间和频率。在页面上移动鼠标可以轻松生成10,000多个评估。 ​ 减少CSS表达式求值次数的一种方法是使用一次性表达式，其中第一次计算表达式时，它将style属性设置为显式值，这将替换CSS表达式。如果必须在页面的整个生命周期中动态设置样式属性，则使用事件处理程序而不是CSS表达式是另一种方法。如果必须使用CSS表达式，请记住它们可能会被评估数千次，并可能影响页面的性能。 将JavaScript和CSS独立成外部文件​ 其中许多性能规则都涉及外部组件的管理方式。但是，在出现这些考虑因素之前，您应该提出一个更基本的问题：JavaScript和CSS是否应该包含在外部文件中，还是内嵌在页面中？ ​ 在现实世界中使用外部文件通常会产生更快的页面，因为浏览器会缓存JavaScript和CSS文件。每次请求HTML文档时，都会下载HTML文档中内联的JavaScript和CSS。这减少了所需的HTTP请求数，但增加了HTML文档的大小。另一方面，如果JavaScript和CSS位于浏览器缓存的外部文件中，则HTML文档的大小会减少，而不会增加HTTP请求的数量。 ​ 因此，关键因素是外部JavaScript和CSS组件相对于请求的HTML文档数量的缓存频率。这个因素虽然难以量化，但可以使用各种指标进行衡量。如果您站点上的用户每个会话有多个页面查看，并且您的许多页面重复使用相同的脚本和样式表，则缓存的外部文件可能会带来更大的潜在好处。 ​ 许多网站都处于这些指标的中间。对于这些站点，最佳解决方案通常是将JavaScript和CSS部署为外部文件。内联的唯一例外是主页，例如Yahoo！的首页和My Yahoo! 。每个会话具有很少（可能只有一个）页面视图的主页可能会发现内联JavaScript和CSS会导致更快的最终用户响应时间。 ​ 对于通常是许多页面视图中的第一个的首页，有一些技术可以利用内联提供的HTTP请求的减少，以及通过使用外部文件实现的缓存优势。其中一种技术是在首页中内联JavaScript和CSS，但在页面加载完成后动态下载外部文件。后续页面将引用应该已存在于浏览器缓存中的外部文件。 减少DNS查询 域名系统（DNS）将主机名映射到IP地址，就像电话簿将人们的姓名映射到他们的电话号码一样。当您在浏览器中键入www.yahoo.com 时，浏览器联系的DNS解析器将返回该服务器的IP地址。DNS有成本。DNS通常需要20-120毫秒才能查找给定主机名的IP地址。在DNS查找完成之前，浏览器无法从此主机名下载任何内容。 缓存DNS查找以获得更好的性能。此缓存可以在由用户的ISP或局域网维护的特殊缓存服务器上进行，但在单个用户的计算机上也存在缓存。DNS信息保留在操作系统的DNS缓存中（Microsoft Windows上的“DNS客户端服务”）。大多数浏览器都有自己的缓存，与操作系统的缓存分开。只要浏览器将DNS记录保存在自己的缓存中，它就不会因操作系统请求记录而烦恼。 默认情况下，Internet Explorer会将DNS查找缓存30分钟，具体 DnsCacheTimeout取决于注册表设置。Firefox将DNS查找缓存1分钟，由network.dnsCacheExpiration配置设置控制。（Fasterfox将此更改为1小时。） 当客户端的DNS缓存为空（对于浏览器和操作系统）时，DNS查找的数量等于网页中唯一主机名的数量。这包括页面的URL，图像，脚本文件，样式表，Flash对象等中使用的主机名。减少唯一主机名的数量可减少DNS查找的数量。 减少唯一主机名的数量有可能减少页面中发生的并行下载量。避免DNS查找会缩短响应时间，但减少并行下载可能会缩短响应时间。我的准则是将这些组件分成至少两个但不超过四个主机名。这导致在减少DNS查找和允许高度并行下载之间的良好折衷。 压缩JavaScript和CSS(包括内联&lt;script&gt;和&lt;style&gt;) 压缩是从代码中删除不必要的字符以减小其大小从而改善加载时间的做法。压缩代码时，将删除所有注释，以及不需要的空格字符（空格，换行符和制表符）。在JavaScript的情况下，这改善了响应时间性能，因为下载文件的大小减小了。用于压缩JavaScript代码的两种流行工具是JSMin和YUI Compressor。YUI压缩器也可以压缩CSS。 混淆是可以应用于源代码的替代优化。它比压缩更复杂，因此更容易因混淆步骤本身而产生错误。在对美国十大顶级网站的调查中，压缩规模缩小了21％，而混淆缩小了25％。尽管混淆具有更高的大小缩减，但压缩JavaScript的风险较小。 除了压缩外部脚本和样式之外，内联&lt;script&gt;和&lt;style&gt;块也可以并且也应该压缩。即使你gzip你的脚本和样式，压缩它们仍然会减小5％或更多的大小。随着JavaScript和CSS的使用和大小的增加，压缩代码所节省的成本也会增加。 避免重定向 使用301和302状态代码完成重定向。以下是301响应中HTTP标头的示例： 123HTTP/1.1 301 Moved PermanentlyLocation: http://example.com/newuriContent-Type: text/html 浏览器自动将用户带到该Location字段中指定的URL 。重定向所需的所有信息都在标题中。响应的主体通常是空的。尽管有其名称，但实际上不会缓存301或302响应，除非其他标题（例如Expires或Cache-Control表示它应该是）。元刷新标记和JavaScript是将用户定向到不同URL的其他方法，但如果必须进行重定向，则首选技术是使用标准3xx HTTP状态代码，主要是为了确保后退按钮正常工作。 要记住的主要事情是重定向会降低用户体验。在用户和HTML文档之间插入重定向会延迟页面中的所有内容，因为页面中的任何内容都无法呈现，并且在HTML文档到达之前不会开始下载任何组件。 最浪费的重定向之一经常发生，Web开发人员通常不了解它。当URL中缺少尾部斜杠（/）时会发生这种情况。例如，转到http://astrology.yahoo.com/astrology会产生301响应，其中包含重定向到http://astrology.yahoo.com/astrology/（注意添加的尾部斜杠）。如果您使用的是Apache处理程序，则可以使用Alias或mod_rewrite或 DirectorySlash指令在Apache中修复此问题。 将旧网站连接到新网站是重定向的另一种常见用途。其他包括连接网站的不同部分并基于特定条件（浏览器类型，用户帐户类型等）指导用户。使用重定向连接两个网站很简单，只需要很少的额外编码。虽然在这些情况下使用重定向会降低开发人员的复杂性，但会降低用户体验。使用重定向的替代方法包括使用Alias以及mod_rewrite两个代码路径是否托管在同一服务器上。如果域名更改是使用重定向的原因，则另一种方法是创建CNAME（创建从一个域名指向另一个域名的别名的DNS记录）与Alias或组合mod_rewrite。 删除重复的脚本 在一个页面中两次包含相同的JavaScript文件会损害性能。这并不像你想象的那么不寻常。对美国十大顶级网站的评论显示，其中两个网站包含重复的脚本。两个主要因素会增加脚本在单个网页中重复的几率：团队规模和脚本数量。当它发生时，重复的脚本会通过创建不必要的HTTP请求和浪费的JavaScript执行来损害性能。 不必要的HTTP请求在Internet Explorer中发生，但在Firefox中不发生。在Internet Explorer中，如果外部脚本包含两次且不可缓存，则在页面加载期间会生成两个HTTP请求。即使脚本是可缓存的，当用户重新加载页面时也会发生额外的HTTP请求。 除了生成浪费的HTTP请求之外，还浪费了多次评估脚本的时间。无论脚本是否可缓存，这种冗余的JavaScript执行都会在Firefox和Internet Explorer中执行。 避免意外包含相同脚本两次的一种方法是在模板系统中实现脚本管理模块。包含脚本的典型方法是在HTML页面中使用SCRIPT标记。 1&lt;script type ="text/javascript" src ="menu_1.0.17.js"&gt;&lt;/script&gt; PHP中的另一种选择是创建一个名为insertScript的函数。 1&lt;? php insertScript（"menu.js"）?&gt; 除了防止多次插入相同的脚本之外，此函数还可以处理脚本的其他问题，例如依赖性检查和向脚本文件名添加版本号以支持远期的Expires头。 配置实体标记ETag 实体标记（ETag）是Web服务器和浏览器用于确定浏览器缓存中的组件是否与源服务器上的组件匹配的机制。（“实体”是另一个词“组件”：图像，脚本，样式表等）。添加ETag以提供验证比上次修改日期更灵活的实体的机制。ETag是唯一标识组件的特定版本的字符串。唯一的格式约束是引用字符串。源服务器使用ETag响应头指定组件的ETag 。 1234HTTP/1.1 200 OKLast-Modified: Tue, 12 Dec 2006 03:03:59 GMTETag: "10c24bc-4ab-457e1c1f"Content-Length: 12195 之后，如果浏览器必须验证组件，它将使用If-None-Match标头将ETag传递回原始服务器。如果ETag匹配，则返回304状态代码，从而将响应减少12195字节。 12345GET /i/yahoo.gif HTTP/1.1Host: us.yimg.comIf-Modified-Since: Tue, 12 Dec 2006 03:03:59 GMTIf-None-Match: "10c24bc-4ab-457e1c1f"HTTP/1.1 304 Not Modified ETag的问题在于它们通常使用属性构建，这些属性使它们对托管站点的特定服务器是唯一的。当浏览器从一个服务器获取原始组件并稍后尝试在不同服务器上验证该组件时，ETag将不匹配，这种情况在使用服务器集群处理请求的网站上非常常见。默认情况下，Apache和IIS都在ETag中嵌入数据，这大大降低了在具有多个服务器的网站上成功进行有效性测试的几率。 Apache 1.3和2.x的ETag格式是inode-size-timestamp。虽然给定文件可以跨多个服务器驻留在同一目录中，并且具有相同的文件大小，权限，时间戳等，但它的inode在服务器与下一个服务器之间是不同的。 IIS 5.0和6.0与ETag有类似的问题。IIS上ETag的格式是Filetimestamp:ChangeNumber。ChangeNumber是用于跟踪IIS配置更改的计数器。后面整个网站的所有IIS服务器ChangeNumber是相同这是不太可能的。 最终结果是Apache和IIS生成的ETag对于完全相同的组件从一台服务器到另一台服务器不匹配。如果ETag不匹配，则用户不会收到ETag设计的小的，快速的304响应; 相反，他们将获得正常的200响应以及组件的所有数据。如果您只在一台服务器上托管您的网站，这不是问题。但是，如果您有多个服务器托管您的网站，并且您正在使用具有默认ETag配置的Apache或IIS，则您的用户正在变慢页面，您的服务器负载更高，您正在消耗更大的带宽，并且代理服务器没有有效地缓存您的内容。即使您的组件具有远期Expires标头，每当用户点击重新加载或刷新时，仍会发出条件GET请求。 如果您没有利用ETag提供的灵活验证模型，最好只删除ETag。该Last-Modified头验证基于对组件的时间戳。删除ETag会减少响应和后续请求中HTTP标头的大小。此Microsoft支持文章介绍了如何删除ETag。在Apache中，只需将以下行添加到Apache配置文件即可： 1FileETag none 使Ajax可以缓存 Ajax的一个优点是它为用户提供即时反馈，因为它从后端Web服务器异步请求信息。但是，使用Ajax并不能保证用户不会在等待那些异步JavaScript和XML响应返回时大拇指。在许多应用程序中，用户是否保持等待取决于Ajax的使用方式。例如，在基于Web的电子邮件客户端中，用户将一直等待Ajax请求的结果，以查找符合其搜索条件的所有电子邮件。重要的是要记住“异步”并不意味着“瞬时”。 ​ 为了提高性能，优化这些Ajax响应非常重要。提高Ajax性能的最重要方法是使响应可缓存，如添加Expires或Cache-controll标头中所述。其他一些规则也适用于Ajax： Gzip组件 减少DNS查找 压缩JavaScript 避免重定向 配置ETag 我们来看一个例子。Web 2.0电子邮件客户端可能使用Ajax下载用户的通讯簿以进行自动完成。如果用户自上次使用电子邮件Web应用程序以来未修改过她的地址簿，则可以从缓存中读取先前的地址簿响应，如果该Ajax响应可以使用将来的Expires或Cache-Control标头进行缓存。必须通知浏览器何时使用先前缓存的地址簿响应而不是请求新的地址簿响应。这可以通过向地址簿Ajax URL添加时间戳来完成，该时间戳指示用户上次修改其地址簿的时间，例如，&amp;t=1190241612。如果自上次下载后地址簿尚未被修改，则时间戳将相同，并且将从浏览器的缓存中读取地址簿，从而消除额外的HTTP往返。如果用户修改了地址簿，则时间戳确保新URL与缓存的响应不匹配，浏览器将请求更新的地址簿条目。 即使您的Ajax响应是动态创建的，并且可能仅适用于单个用户，它们仍然可以缓存。这样做可以使您的Web 2.0应用程序更快。 尽早清除缓存 当用户请求页面时，后端服务器可能需要200到500毫秒才能将HTML页面拼接在一起。在此期间，浏览器在等待数据到达时处于空闲状态。在PHP中，您有函数flush()。它允许您将部分准备好的HTML响应发送到浏览器，以便浏览器可以在后端忙于HTML页面的其余部分时开始获取组件。这种好处主要出现在繁忙的后端或轻量级前端。 考虑刷新的好地方就在HEAD之后，因为头部的HTML通常更容易生成，并且它允许您包含任何CSS和JavaScript文件，以便浏览器在后端处理时并行地开始获取。 例： 12345&lt;!-- css,js --&gt;&lt;/head&gt;&lt;?php flush();?&gt;&lt;body&gt;&lt;!-- content --&gt; 雅虎 搜索开创性研究和真实用户测试，以证明使用此技术的好处。 使用GET进行Ajax请求 在雅虎 邮件团队发现，在使用时XMLHttpRequest，POST在浏览器中实现为两步过程：首先发送标头，然后发送数据。因此最好使用GET，它只需要一个TCP数据包发送（除非你有很多cookie）。IE中的最大URL长度为2K，因此如果发送的数据超过2K，则可能无法使用GET。 一个有趣的副作用是没有实际发布任何数据的POST就像GET一样。根据HTTP规范，GET用于检索信息，因此当您仅请求数据时，使用GET是有意义的（语义上），而不是将数据发送到服务器端存储。 延迟加载组件 您可以仔细查看您的页面并问自己：“页面最初渲染必要的是什么？”。其余的内容和组件可以等待。 JavaScript是在onload事件之前和之后拆分的理想候选者。例如，如果您有执行拖放和动画的JavaScript代码和库，则可以等待，因为在初始渲染之后拖动页面上的元素。其他寻找后期加载候选者的地方包括隐藏内容（用户操作后显示的内容）和首屏下方的图像。 帮助您完成工作的工具：YUI Image Loader允许您将图像延迟到折叠下方，YUI Get实用程序是一种简单的方法，可以动态地包含JS和CSS。在野外的例子看看雅虎！打开Firebug网络面板的主页。 当性能目标与其他Web开发最佳实践一致时，这是很好的。在这种情况下，渐进增强的想法告诉我们，JavaScript在受支持时可以改善用户体验，但您必须确保即使没有JavaScript也能正常工作。因此，在确保页面正常工作之后，您可以使用一些后期加载的脚本来增强它，这些脚本可以为您提供更多的花俏功能，例如拖放和动画。 预加载组件 预加载可能看起来与延迟加载相反，但它实际上有不同的目标。通过预加载组件，您可以利用浏览器空闲的时间并请求将来需要的组件（如图像，样式和脚本）。这样，当用户访问下一页时，您可以将大部分组件放在缓存中，并且您的页面将为用户加载更快。 实际上有几种类型的预加载： 无条件预加载 - 一旦onload触发，你就可以继续获取一些额外的组件。请访问google.com，了解如何请求加载精灵图片。google.com主页上不需要此精灵图片，但在连续搜索结果页面上需要此精灵图片。 条件预加载 - 基于用户操作，您可以进行有根据的猜测，即用户前进的位置并相应地预加载。在search.yahoo.com上，您可以看到在开始输入输入框后如何请求一些额外的组件。 预期的预加载 - 在启动重新设计之前提前预加载。经常在重新设计之后听到：“新网站很酷，但比以前慢”。部分问题可能是用户使用完整缓存访问旧网站，但新网站始终是空缓存体验。您可以通过在启动重新设计之前预加载某些组件来缓解此副作用。您的旧站点可以使用浏览器空闲的时间并请求新站点将使用的图像和脚本 减少DOM元素的数量 复杂页面意味着要下载更多字节，这也意味着JavaScript中的DOM访问速度更慢。例如，当您想要添加事件处理程序时，如果在页面上循环遍历500或5000个DOM元素，则会有所不同。 大量的DOM元素可能是一种通症，即应该通过页面标记来改进，而不必删除内容。您是否使用嵌套表进行布局？您是否只是为了解决布局问题而投入更多&lt;div&gt;？也许有一种更好，语义更正确的标记方式。 YUI CSS实用程序 提供了很好的布局帮助：grids.css可以帮助您完成整体布局，fonts.css和reset.css可以帮助您去除浏览器的默认格式。这是一个重新开始并考虑标记的机会，例如，&lt;div&gt;只有在语义上有意义时才使用s，而不是因为它呈现新行。 DOM元素的数量很容易测试，只需键入Firebug的控制台： 1document.getElementsByTagName('*').length; 那到底有多少DOM元素才算少？检查具有良好标记的其他类似页面。例如雅虎！主页是一个非常繁忙的页面，仍然不到700个元素（HTML标记）。 跨域拆分组件 拆分组件允许您最大化并行下载。由于DNS查询惩罚，请确保您使用的域名不超过2-4个。例如，您可以托管HTML和动态内容，www.example.org 并在static1.example.org和之间拆分静态组件static2.example.org 有关更多信息，请查看Tenni Theurer和Patty Chi的“ 在Carpool Lane中最大化并行下载 ”。 最小化iframe数量 iframe允许将HTML文档插入父文档中。了解iframe如何运作以便有效使用非常重要。 &lt;iframe&gt; 优点： 帮助缓慢的第三方内容，如徽章和广告 安全沙箱 并行下载脚本 &lt;iframe&gt; 缺点： 即使空白也要花钱 阻止页面onload 非语义 尽量不用404s HTTP请求很昂贵，因此发出HTTP请求并获得无用的响应（即404 Not Found）是完全没必要的，并且会在没有任何好处的情况下减慢用户体验。 有些网站有帮助404表示 ”你的意思是XXX？”，这对用户体验很有好处，但也浪费了服务器资源（比如数据库等）。特别糟糕的是当外部JavaScript的链接错误并且结果是404时。首先，此下载将阻止并行下载。接下来，浏览器可能会尝试解析404响应主体，就像它是JavaScript代码一样，试图找到可用的东西。 减小Cookie大小 HTTP cookie的使用有多种原因，例如身份验证和个性化。有关cookie的信息在Web服务器和浏览器之间的HTTP标头中进行交换。保持cookie的大小尽可能低是非常重要的，以尽量减少对用户响应时间的影响。 欲了解更多信息，请查看 Tenni Theurer和Patty Chi撰写的“当Cookie崩溃时”。这项研究的主要内容： 消除不必要的cookie 保持cookie大小尽可能低，以尽量减少对用户响应时间的影响 请注意在适当的域级别设置cookie，以免其他子域受到影响 适当地设置过期日期。较早的Expires日期或者没有更早删除cookie，从而改善了用户响应时间 对组建使用cookie-free的域名 当浏览器发出静态图像请求并将cookie与请求一起发送时，服务器对这些cookie没有任何用处。所以他们只是没有充分理由创建网络流量。您应该确保使用无cookie请求请求静态组件。创建一个子域并在那里托管所有静态组件。 如果您的域名是www.example.org，您可以托管您的静态组件static.example.org。但是，如果您已经在顶级域上设置了cookie example.org而不是www.example.org，则所有请求都 static.example.org将包含这些cookie。在这种情况下，您可以购买一个全新的域，在那里托管您的静态组件，并保持此域无cookie。雅虎 用途yimg.com，YouTube使用ytimg.com，亚马逊使用images-amazon.com等。 在无cookie域上托管静态组件的另一个好处是，某些代理可能拒绝缓存使用cookie请求的组件。在相关说明中，如果您想知道是否应该使用https://example.org或https://www.example.org作为主页，请考虑cookie的影响。省略www会让您别无选择，只能写入cookie *.example.org，因此出于性能原因，最好使用www子域并将cookie写入该子域。 最小化DOM的访问次数​ 使用JavaScript访问DOM元素的速度很慢，因此为了获得响应更快的页面，您应该： 缓存对访问元素的引用 更新节点“离线”，然后将它们添加到树中 避免使用JavaScript修复布局 有关更多信息，请查看 Julien Lecomte 的YUI影院的 “高性能Ajax应用程序”。 开发巧妙的事件处理程序 有时页面感觉响应性较差，因为过多的事件处理程序附加到DOM树的不同元素，然后执行得太频繁。这就是为什么使用事件委托是一个很好的方法。如果a中有10个按钮div，则只将一个事件处理程序附加到div包装器，而不是每个按钮一个处理程序。事件冒出来，这样你就可以捕捉事件并找出它来自哪个按钮。 您也不需要等待onload事件以便开始使用DOM树执行某些操作。通常，您只需要在树中访问要访问的元素。您不必等待下载所有图像。DOMContentLoaded是您可能考虑使用的事件而不是onload，但在所有浏览器中都可用之前，您可以使用具有方法的YUI事件实用程序onAvailable。 有关更多信息，请查看 Julien Lecomte 的YUI影院的 “高性能Ajax应用程序”。 优先选择使用&lt;link&gt;而非@import 之前的最佳实践之一声明CSS应位于顶部以允许渐进式渲染。 在IE中，@import行为与&lt;link&gt;在页面底部使用相同，因此最好不要使用它。 避免使用filters IE专有的AlphaImageLoader过滤器旨在解决IE版本&lt;7中的半透明真彩色PNG的问题。该过滤器的问题在于它在下载图像时阻止渲染并冻结浏览器。它还会增加内存消耗，并且每个元素应用，而不是每个图像，因此问题成倍增加。 最好的方法是AlphaImageLoader完全避免使用优雅降级的PNG8，这在IE中很好。如果你绝对需要AlphaImageLoader，使用下划线黑客_filter不会惩罚你的IE7 +用户。 优化图片 设计师完成为您的网页创建图像后，在将这些图像FTP到Web服务器之前，仍然可以尝试一些操作。 您可以检查GIF并查看它们是否使用与图像中颜色数对应的调色板大小。使用imagemagick很容易检查 identify -verbose image.gif 当你在调色板中看到使用4种颜色和256色“槽”的图像时，还有改进的余地。 尝试将GIF转换为PNG并查看是否存在保存。通常，有。由于浏览器的支持有限，开发人员经常对使用PNG犹豫不决，但现在已成为过去。唯一真正的问题是真彩色PNG中的alpha透明度，但是GIF也不是真彩色，也不支持变量透明度。所以GIF可以做任何事情，调色板PNG（PNG8）也可以做（动画除外）。这个简单的imagemagick命令导致完全安全的PNG： convert image.gif image.png 我们所说的只是：给PiNG一个机会！” 在所有PNG上 运行pngcrush（或任何其他PNG优化工具）。例： pngcrush image.png -rem alla -reduce -brute result.png 在所有JPEG上运行jpegtran。此工具执行无损JPEG操作（如旋转），还可用于优化和删除图像中的注释和其他无用信息（如EXIF信息）。 jpegtran -copy none -optimize -perfect src.jpg dest.jpg 优化CSS Sprites 将图像水平排列在精灵中而不是垂直排列通常会导致文件较小。 在精灵中组合相似的颜色可以帮助您保持较低的颜色数，理想情况下在256色以下，以适应PNG8。 “适合移动设备”并且不要在精灵中留下大的间隙。这不会影响文件大小，但需要较少的内存，以便用户代理将图像解压缩为像素图。100x100图像是1万像素，其中1000x1000是100万像素 不要在HTML中缩放图像 不要使用比您需要的更大的图像，因为您可以在HTML中设置宽度和高度。如果您需要， 1&lt;img width="100" height="100" src="mycat.jpg" alt="My Cat" /&gt; 那么您的图像（mycat.jpg）应该是100x100px而不是缩小的500x500px图像。 减小favicon.ico的大小并缓存 favicon.ico是一个保留在服务器根目录中的映像。这是一个必要的邪恶，因为即使你不关心它，浏览器仍然会请求它，所以最好不要回复404 Not Found。此外，由于它位于同一台服务器上，因此每次请求时都会发送cookie。此图像也会干扰下载顺序，例如在IE中，当您在onload中请求额外组件时，将在这些额外组件之前下载favicon。 因此，为了减轻拥有favicon.ico的缺点，请确保： 它很小，最好不到1K。 使用您感觉舒适的设置Expires标头（因为如果您决定更改它，则无法重命名）。您可以在将来几个月安全地设置Expires标头。您可以查看当前favicon.ico的上次修改日期，以做出明智的决定。 Imagemagick可以帮助您创建小的favicons 保持组件小于25K 此限制与iPhone不会缓存大于25K的组件这一事实有关。请注意，这是未压缩的大小。这是缩小很重要的地方，因为单独使用gzip可能还不够。 ​ 欲了解更多信息，请查看Wayne Shea和Tenni Theurer的性能研究，第5部分：iPhone可缓存性 - 让它坚持下去 。 将组件拆分到多个文档中 将组件打包到多部分文档就像带有附件的电子邮件，它可以帮助您通过一个HTTP请求获取多个组件（请记住：HTTP请求很昂贵）。使用此技术时，首先检查用户代理是否支持它（iPhone不支持）。 避免设置空图像的src 带有空字符串src属性的图像会出现多个预期。它以两种形式出现： HTML 1&lt;img src =""&gt; JavaScript 12var img = new Image();img.src =""; 两种形式都会产生相同的效果：浏览器向您的服务器发出另一个请求 Internet Explorer向页面所在的目录发出请求。 Safari和Chrome会向实际页面提出请求。 Firefox 3及更早版本的行为与Safari和Chrome相同，但3.5版解决了此问题[错误444931]，不再发送请求。 遇到空图像时，Opera不执行任何操作。 为什么这种行为不好？ 通过发送大量意外流量来削弱您的服务器，特别是对于每天获得数百万页面浏览量的页面。 废弃服务器计算周期生成永远不会被查看的页面。 可能会损坏用户数据。如果您通过cookie或其他方式跟踪请求中的状态，则可能会破坏数据。即使图像请求未返回图像，浏览器也会读取并接受所有标头，包括所有cookie。虽然其余的响应被丢弃，但可能已经造成了损害。 此行为的根本原因是在浏览器中执行URI解析的方式。此行为在RFC 3986 - 统一资源标识符中定义。当遇到空字符串作为URI时，它被视为相对URI，并根据5.2节中定义的算法进行解析。这个具体的例子是一个空字符串，在5.4节中列出。Firefox，Safari和Chrome都按照规范正确解析空字符串，而Internet Explorer正在解析它，显然符合规范的早期版本RFC 2396 - 统一资源标识符（这已被RFC 3986废弃） 。从技术上讲，浏览器正在做他们应该做的事情来解析相对URI。问题是在这种情况下， ​ HTML5添加了img标记的src属性的描述，以指示浏览器不要在4.8.2节中提出额外的请求： src属性必须存在，并且必须包含引用非交互式（可选动画）图像资源的有效URL，该资源既不是分页也不是脚本。如果元素的基URI与文档的地址相同，则src属性的值不能是空字符串。 希望浏览器将来不会出现这个问题。不幸的是，&lt;script src =&quot;&quot;&gt;和&lt;link href =&quot;&quot;&gt;没有这样的子句。也许还有时间进行调整以确保浏览器不会意外地实现此行为。 这条规则的灵感来自雅虎的JavaScript大师Nicolas C. Zakas。有关更多信息，请查看他的文章“ Empty image src can destroy your site ”。]]></content>
      <tags>
        <tag>Web</tag>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[给求职者的几点建议]]></title>
    <url>%2FBlog%2F2018%2F11%2F11%2F%E7%BB%99%E6%B1%82%E8%81%8C%E8%80%85%E7%9A%84%E5%87%A0%E7%82%B9%E5%BB%BA%E8%AE%AE%2F</url>
    <content type="text"><![CDATA[12提前准备：准备好每一类问题，给自己一次审视自己，重新认识自我的机会。 自我介绍Question: 11&gt; 请你用三分钟时间做一个简单的自我介绍? 考察项： 执行力 理解力 换位思考 意识倾向 1. 执行力、理解力​ 是否听清面试官的要求，主要看应聘者是否有反应，要控制在面试官要求的时间范围内，如果没有把握，可以征询面试官是否要计时。 2. 换位思考​ 不要对简历照念，复述型的自我介绍不好，好的自我介绍要回答我为什么应聘该岗位，我为什么适合该岗位。我喜欢要先说对公司和岗位的理解，我适合要说我的特长和能力。与公司和岗位要求恰恰是相符合的。 4. 意识倾向12&gt; 答一：“我有很强的思维能力、学习能力、计划能力...”&gt; 答二：“我有很强的沟通能力、协调能力、组织能力以及领导能力...” 回答提示: 不要照着简历念,企业想知道能否胜任工作.需要包括最强的技能,最深入研究的知识领域,个性中最积极的部分,做过的最成功的事,主要的成就等,这些都可以和学习无关,也可以和学习有关,但要突出积极的个性和做事的能力,说得合情合理HR才会相信.HR很注重一个人的礼貌,求职者要尊重面试官,在回答每个问题之后都说一句”谢谢”,有礼貌的求职者人人都喜欢. 网申开放题怎么答？12&gt; 开放题侧重考察个人的合作能力和技巧，工作的抗压能力，是否有不利于工作和团队发展的一些问题等。&gt; 开放性问题在正式找工作之前就应该去做，抽时间搞明白自己的优势和劣势。比如，我是个什么样的人，我在学校做了哪些牛叉的工作，取得了哪些突出的成就，这些成就体现了我的哪些气质，这种气质的我应该找什么类型的工作。即认清了自己，也能够轻松应对求职面试问题，岂不是一石二鸟，美滋滋~ Question 1: 价值观 你做的最成功/最失败的一件事是什么？让你感到最有成就感的是什么？让你感到最遗憾的一件事是什么？ 这类问题，HR主要考察的你的价值观导向，在你眼里什么是最重要；对你来说，什么才算成功。 我收集了几点通常的做法： Question 2: 未来规划 谈谈你的职业规划？ 这类问题，HR希望挖掘你应聘的深层次动机，看你是否具有职业稳定性。 Question 3: 学习能力 谈谈你是怎样学习(前端 or 后端)的? 这类问题就谈你从多种渠道，全方位，立体式的挖掘你对某一领域的研究成果或方式，展现你的浓厚的兴趣和强烈的好奇心，回答越具体越好。 请问你最近在看什么书？ Question 4: 解决问题能力 说说你曾经面对过哪些困难，你是如何解决的？举一个令你印象最深的一个。 1&gt; 尽管HR问的是困难经历，但是HR在意的并不是结果，而是想了解应聘者在这次经历中学到的一些东西，吸取了什么教训，从而考察其学习能力和应变能力及抗压能力。在面试中类似的问题还有“你最自豪的一件事” “你在学习和工作中最难忘的一件事” “谈谈你的一次失败经历”等。 举例 我: 我曾经作为某某活动的负责人{组织者、发起人等等}组织了某某活动{参加某某比赛实践项目}，期间我做了很多努力{比如}但是由于一些原因{自己的原因}，最终没能达到预期的效果。虽然结果令人遗憾，但是我从中认识到了不足，也积累了经验，汲取的教训，谈谈自己的收获。最后，我认为失败是在所难免的，有时候失败比成功更能促进人的进步，经过我的锻炼和学习，我相信如果再经历相关的实践工作，我一定会做的更好！ Question 5: 性格测验 请问在你同学和老师眼中你分别是一个什么样的人？ 1&gt; 角色丰富的人，在同学眼中与在老师眼中的自己是不一样的。找准定位，角色丰富的人知道什么场景下自己就应该表现什么行为，见到什么人应该说什么话，会有比较良好的人际关系。而这一点，对于有些人很简单做的，而对于另一拨人则不容易，楼主恰恰属于后者。再描述一下自己在不同人眼中的共性，就更完美了，说明自己的换位思考能力比较强，能站在对方的立场，角色感比较强，不是一个没有原则，见风使舵，两面三刀的人。 Question5: 思维独立 你最崇拜或你最敬仰的人是谁？ Question6: 自我接纳 在上一份实习中，你收获了什么，学到了什么？ Question7: 执行力、自我明示性 请介绍一下你的优缺点？ 1&gt; 好的回答：我个人理解的优缺点不是绝对的，都需要背景和假设前提来衬托的，我来说说我的特点吧，我做事认真，在出错率低方面是个优点，在效率方面是个缺点，我已经意识到自己的这个问题了，正在努力在要求不是那么细致的工作上提高效率。企业喜欢求职者从自己的优点说起,中间加一些小缺点,最后把问题转回到优点上,突出优点部分,企业喜欢聪明的求职者. 侧重个性方面的优点: 沉着冷静,条理清楚,立场坚定,顽强向上,乐于助人和关心他人,适应能力和幽默感,乐观和友爱等,结合自己的亲身经历,举例描述自己的优点. 你对加班的看法？1&gt; 实际上好多公司问这个问题,是想测试你是否愿意为公司奉献. 你可以这样回答: 如果工作需要,我会义不容辞加班,我现在单身,没有家庭负担,可以全身心的投入工作中.但同时我也会提高工作效率,减少不必要的加班. 你对跳槽的看法? 12&gt; 正常的"跳槽"能促进人才的合理流动,应该支持.&gt; 频繁的跳槽对单位和个人双方都不利,应该反对. 工作中难以和同事,上司相处,你该怎么办? 1234&gt; 我会服从领导的指挥,配合好同事的工作.&gt; 我会从自身找原因,仔细分析是不是自己的工作做的不好让领导不满意,同事看不惯.还要看看为人处世方面做的好不好,如果是自己的原因,我会努力改正.&gt; 如果找不到原因,我会找合适的机会跟他们沟通,请他们指出我的不足,有问题就及时改正.&gt; 作为优秀的员工,应该时刻以大局为重,即使在一段时间内,领导和同事对我不理解,我也会做好本职工作,虚心向他们学习,我相信,他们会看见我的努力,总有一天会对我微笑的. 你如何对待别人的批评? 12&gt; 我会接受建设性的批评&gt; 我会等大家冷静下来再讨论.]]></content>
      <categories>
        <category>求职</category>
      </categories>
      <tags>
        <tag>应聘</tag>
        <tag>经验</tag>
        <tag>职场</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[post_name]]></title>
    <url>%2FBlog%2F2018%2F11%2F10%2Fpost-name%2F</url>
    <content type="text"><![CDATA[图片相对地址测试 音乐加载 var ap = new APlayer({ element: document.getElementById("aplayer-naLpwBvT"), narrow: false, autoplay: false, showlrc: false, music: { title: "Hotel California", author: "Eagles", url: "Hotel California.mp3", pic: "/Blog/2018/11/10/post-name/Hotel%20California.jpg", lrc: "" } }); window.aplayers || (window.aplayers = []); window.aplayers.push(ap); 无宽高设置 宽高设置 突破容器限制HTML方式: 直接在 Markdown 文件中编写 HTML 来调用其中 class=&quot;full-image&quot; 是必须的 标签 方式，要求版本在0.4.5或以上1&lt;span itemprop="image" itemscope itemtype="http://schema.org/ImageObject"&gt;&lt;img itemprop="url image" src="https://theme-next.iissnan.com/uploads/tags/full-image.jpg" class="full-image" alt="alt" title="title" /&gt;&lt;meta itemprop="width" content="auto"&gt;&lt;meta itemprop="height" content="auto"&gt;&lt;/span&gt; fi别名1&lt;span itemprop="image" itemscope itemtype="http://schema.org/ImageObject"&gt;&lt;img itemprop="url image" src="https://theme-next.iissnan.com/uploads/tags/full-image.jpg" class="full-image" alt="alt" title="title" /&gt;&lt;meta itemprop="width" content="auto"&gt;&lt;meta itemprop="height" content="auto"&gt;&lt;/span&gt;]]></content>
      <tags>
        <tag>test</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Something Wrong]]></title>
    <url>%2FBlog%2F2018%2F11%2F10%2FSomething-Wrong%2F</url>
    <content type="text"><![CDATA[Github 子项目如下图所示： ​ 当通过标题展开文章内容时，root地址将会重复加载，使url链接失效 click title after… ​ 当通过下方缩放按钮获取整篇文章内容时，链接是有效的。 more than… 按照hexo 官方文档中如下设置在命令$ hexo g 生成的文档中，最终被解析出的静态文档index.html中的链接中又重复添加了子文件夹中的/Blog 设置情况 解析情况]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>site</tag>
        <tag>subdirectory</tag>
        <tag>title</tag>
        <tag>problem</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Makerdown Syntax]]></title>
    <url>%2FBlog%2F2018%2F11%2F09%2FMakerdown-Syntax%2F</url>
    <content type="text"><![CDATA[HTML ElementsBelow is just about everything you’ll need to style in the theme. Check the source code to see the many embedded elements within paragraphs. Heading 1Heading 2Heading 3Heading 4Heading 5Heading 6Body textLorem ipsum dolor sit amet, test link adipiscing elit. This is strong. Nullam dignissim convallis est. Quisque aliquam. This is emphasized. Donec faucibus. Nunc iaculis suscipit dui. 53 = 125. Water is H2O. Nam sit amet sem. Aliquam libero nisi, imperdiet at, tincidunt nec, gravida vehicula, nisl. The New York Times (That’s a citation). Underline.Maecenas ornare tortor. Donec sed tellus eget sapien fringilla nonummy. Mauris a ante. Suspendisse quam sem, consequat at, commodo vitae, feugiat in, nunc. Morbi imperdiet augue quis tellus. HTML and CSS are our tools. Mauris a ante. Suspendisse quam sem, consequat at, commodo vitae, feugiat in, nunc. Morbi imperdiet augue quis tellus. Praesent mattis, massa quis luctus fermentum, turpis mi volutpat justo, eu volutpat enim diam eget metus. Blockquotes Lorem ipsum dolor sit amet, test link adipiscing elit. Nullam dignissim convallis est. Quisque aliquam. List TypesOrdered Lists Item one sub item one sub item two sub item three Item two Unordered Lists Item one Item two Item three Tables Header1 Header2 Header3 cell1 cell2 cell3 cell4 cell5 cell6 —– cell1 cell2 cell3 cell4 cell5 cell6 ===== Foot1 Foot2 Foot3 Code Snippets12345#container &#123; float: left; margin: 0 -240px 0 0; width: 100%;&#125; ButtonsMake any link standout more when applying the .btn class. 1&lt;a href="#" class="bs-callout bs-callout-warning"&gt;Success Button&lt;/a&gt; Success ButtonWarning ButtonDanger ButtonInfo Button KBDYou can also use &lt;kbd&gt; tag for keyboard buttons. 1&lt;kbd&gt;W&lt;/kbd&gt;&lt;kbd&gt;A&lt;/kbd&gt;&lt;kbd&gt;S&lt;/kbd&gt;&lt;kbd&gt;D&lt;/kbd&gt; Press WASD to move your car. Midtown Maddness!! NoticesWatch out! You can also add notices by appending {: .notice} to a paragraph.]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>makerdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2FBlog%2F2018%2F11%2F09%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
</search>
