<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Knight&#39;s Blog</title>
  
  <subtitle>Web C/C++ Php Python Java... Enjoy Programming!</subtitle>
  <link href="/Blog/atom.xml" rel="self"/>
  
  <link href="https://www.knightboy.cn/Blog/"/>
  <updated>2018-11-25T13:19:56.782Z</updated>
  <id>https://www.knightboy.cn/Blog/</id>
  
  <author>
    <name>Knight</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>JavaScript中的内存回收机制</title>
    <link href="https://www.knightboy.cn/Blog/2018/11/25/JavaScript%E4%B8%AD%E7%9A%84%E5%86%85%E5%AD%98%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/"/>
    <id>https://www.knightboy.cn/Blog/2018/11/25/JavaScript中的内存回收机制/</id>
    <published>2018-11-24T16:00:00.000Z</published>
    <updated>2018-11-25T13:19:56.782Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\Blog\assets\css\APlayer.min.css"><script src="\Blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="一、内存泄漏"><a href="#一、内存泄漏" class="headerlink" title="一、内存泄漏"></a>一、内存泄漏</h2><p>​       由于某些原因不再需要的内存没有被操作系统或则空闲内存池回收。编程语言中有多种管理内存的方式。这些方式从不同程度上会减少内存泄漏的几率，高级语言嵌入了一个名为垃圾收集器的软件，其工作是跟踪内存分配和使用，以便找到不再需要分配内存的时间，在这种情况下，它将自动释放它。然而，该过程是近似的，因为知道是否需要某些存储器的一般问题是不可判定的（不能通过算法来解决）。</p><h3 id="1-1-循环引用导致的内存泄漏"><a href="#1-1-循环引用导致的内存泄漏" class="headerlink" title="1.1 循环引用导致的内存泄漏"></a><strong>1.1 循环引用导致的内存泄漏</strong></h3><p>​       当两个对象相互引用时，会形成一个循环引用，使每个对象的引用计数为1，在纯粹的垃圾收集系统中，循环引用不是问题：如果任何其他对象都不引用所涉及的对象，则两者都是会被视为垃圾而回收。但是，在引用计数系统中，两个对象都不能被销毁，因为引用计数永远不会减到零。在使用垃圾回收和引用计数的混合系统中，由于系统无法识别循环引用而导致泄漏。在这种情况下，DOM对象和Javascript对象都不会被破坏。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">    document.write("Circular referances between Javascript and DOM!");</span></span><br><span class="line"><span class="undefined">    var obj;</span></span><br><span class="line"><span class="undefined">    window.onload = function() &#123;</span></span><br><span class="line"><span class="undefined">        obj = document.getElementById("DivElement");</span></span><br><span class="line"><span class="undefined">        document.getElementById("DivElement").expandoProperty = obj;</span></span><br><span class="line"><span class="undefined">        Array(1000).join(new Array(2000).join("XXXXX"));</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"DivElement"</span>&gt;</span>Div Element<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>​       如上面代码所示，Javascript对象obj引用了DivElement表示的DOM对象。DOM对象反过来又通过expandoProperty对Javascript对象有一个引用。Javascript对象和DOM对象之间存在循环引用。因为DOM对象通过引用计数进行管理，所以两个对象都不会被销毁。</p><h3 id="1-2-外部函数引起的循环引用"><a href="#1-2-外部函数引起的循环引用" class="headerlink" title="1.2 外部函数引起的循环引用"></a><strong>1.2 外部函数引起的循环引用</strong></h3><p>​       下面代码中，通过调用外部函数myFunction来创建循环引用。Javascript对象和DOM对象之间的循环引用将最终导致内存泄漏。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.write(<span class="string">"Circular references between Javascript and DOM!"</span>);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myFunction</span>(<span class="params">element</span>) </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.elementReferences = element;</span><br><span class="line"><span class="comment">//this code forms a circular references here</span></span><br><span class="line"><span class="comment">//by DOM--&gt;JS--&gt;DOM</span></span><br><span class="line">element.expandoProperty = <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Leak</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="comment">//this code will leak;</span></span><br><span class="line"><span class="keyword">new</span> myFunction(<span class="built_in">document</span>.getElementById(<span class="string">"myDiv"</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​       正如上面这两类代码示例所显示的，循环很容易创建。他们还倾向于在Javascript中最方便的编程结构：闭包。</p><h3 id="1-3-闭包引起的内存泄漏"><a href="#1-3-闭包引起的内存泄漏" class="headerlink" title="1.3 闭包引起的内存泄漏"></a><strong>1.3 闭包引起的内存泄漏</strong></h3><p>​       Javascript的优点之一是它允许函数嵌套在其他函数之中，嵌套内部函数可以继承外部函数的参数和变量，并且对该函数是私有的。Javascript开发人员使用内部函数将小效用函数集成到其他函数中，使得内部函数（childFunction）可以访问外部parentFunction的变量。当一个内部函数获取并使用对其外部函数变量的访问时，它称为<strong>闭包</strong>。</p><p>​       一个简单的闭包例子</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.write(<span class="string">"Closure Demo!"</span>);</span><br><span class="line"><span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span> <span class="title">closureDemoParentFunction</span>(<span class="params">paramA</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> a = paramA;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">closureDemoInnerFunction</span>(<span class="params">paramB</span>)</span>&#123;</span><br><span class="line">    alert(a + <span class="string">" "</span> + paramB);</span><br><span class="line">&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> x=closureDemoParentFunction(<span class="string">"outer x"</span>);</span><br><span class="line">x(<span class="string">"inner x"</span>);</span><br></pre></td></tr></table></figure><p>​       在上面的代码中，closureDemoInnerFunction是父函数closureDemoParentFunction中定义的内部函数。当用外部x的参数对closureDemoParentFunction进行调用时，外部函数变量a被赋值外部x。函数返回一个指向内部函数closureDemoInnerFunction的指针，它包含在变量x中。必须注意的是，外部函数closureDemoParentFunction的局部变量a即使在外部函数返回后也会存在。这与C++等编程语言不同，在函数返回后，局部变量不再存在。在Javascript中，调用closureDemoParentFunction的时刻，创建一个具有属性a的作用域对象。此属性包含paramA的值，也称为”outer x”。同样，当closureDemoParentFunction 返回时，它将返回内部函数closureDemoInnerFunction，它包含在变量x中。</p><p>​       由于内部函数持有对外部函数的变量的引用，因此具有属性a的作用域对象不会被垃圾回收。当在x上用一个参数值（即x(“inner x”)进行调用时，将弹出一个显示”outer x inner x”的警报。闭包功能强大，因为它们允许内部函数在外部函数返回后保留对外部函数变量的访问权限。<strong>遗憾的是，闭包在Javascript对象和DOM对象之间隐藏循环引用非常出色。</strong></p><p>​       由于IE9之前的版本对Javascript对象和COM对象使用不同的垃圾回收例程，因此闭包在这些版本中会导致一些特殊的问题。具体来说，如果闭包的作用域中保存着一个HTML元素，那么就意味着该元素将无法被销毁。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">assignHandler</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> element = <span class="built_in">document</span>.getElementById(<span class="string">"my_btn"</span>);</span><br><span class="line">    element.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">         alert(element.id);</span><br><span class="line">     &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​       以上代码创建了一个作为element元素事件处理程序的闭包，而这个闭包又创建了一个循环引用。由于匿名函数保存了一个对<code>assignHandler()</code>的活动对象的引用，因此就会导致无法减少element的引用数。只要匿名函数存在，element的引用数至少也是1，因此它占用的内存永远也会被回收。不过，这个问题是可以被解决的：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">assignHandler</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> element = <span class="built_in">document</span>.getElementById(<span class="string">"my_btn"</span>);</span><br><span class="line">    <span class="keyword">var</span> id = element.id;</span><br><span class="line">    element.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">         alert(id);</span><br><span class="line">     &#125;;</span><br><span class="line">    element = <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​       上面代码，是把element.id的一个副本保存在一个变量中，并且在闭包中引用该变量消除循环引用，但是，这种程度还不能解决内存泄露的问题。必须要记住：闭包会引用包含函数的整个活动对象，而这其中包含着element。即使闭包不直接引用element，包含函数的活动对象中也仍然会保存着一个引用。因此，必须要把element变量设置为null。这样就能解除对DOM对象的引用，顺利减少引用次数，确保回收其占用的内存。</p><h3 id="1-4-事件处理程序引起的内存泄漏"><a href="#1-4-事件处理程序引起的内存泄漏" class="headerlink" title="1.4 事件处理程序引起的内存泄漏"></a><strong>1.4 事件处理程序引起的内存泄漏</strong></h3><p>​      在下面的代码中，你将会发现，一个JavaScript对象（obj）包含对DOM对象（由id”元素”引用）的引用的闭包。DOM元素反过来又具有对Javascript obj的引用。在Javascript对象和DOM对象之间产生的循环引用会导致内存泄漏。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="built_in">document</span>.write(<span class="string">"Program to illustrate memory leak via closure"</span>);</span></span><br><span class="line"><span class="javascript">    <span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span> <span class="title">outerFunction</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> obj = <span class="built_in">document</span>.getElementById(<span class="string">"element"</span>);</span></span><br><span class="line"><span class="javascript">        obj.onclick = <span class="function"><span class="keyword">function</span> <span class="title">innerFunction</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">            alert(<span class="string">"Hi!,I will leak"</span>);</span></span><br><span class="line"><span class="undefined">        &#125;;</span></span><br><span class="line"><span class="javascript">        obj.bigString = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">1000</span>).join(<span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">2000</span>).join(<span class="string">"XXXXX"</span>));</span></span><br><span class="line"><span class="undefined">    &#125;;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">"element"</span>&gt;</span>Click Me<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="1-5-避免内存泄漏的方法"><a href="#1-5-避免内存泄漏的方法" class="headerlink" title="1.5 避免内存泄漏的方法"></a><strong>1.5 避免内存泄漏的方法</strong></h3><p>​       在Javascript中，内存泄露的另一方面是你可以避免它们。当您确定了可以导致循环引用的模式时，正如前面所列举的那样，您可以开始围绕它们进行工作。我们将使用上面三种的事件处理中内存泄漏的方式解决已知内存泄露的方法。一个简单的解决方案是使Javascript对象obj设为null，从而显式中断循环引用。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="built_in">document</span>.write(<span class="string">"Avoiding memory leak via closure by breaking the circular reference"</span>);</span></span><br><span class="line"><span class="javascript">    <span class="built_in">window</span>.onload=<span class="function"><span class="keyword">function</span> <span class="title">outerFunction</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> obj = <span class="built_in">document</span>.getElementById(<span class="string">"element"</span>);</span></span><br><span class="line"><span class="javascript">        obj.onclick=<span class="function"><span class="keyword">function</span> <span class="title">innerFunction</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">            alert(<span class="string">"Hi! I have avoided the leak"</span>);</span></span><br><span class="line"><span class="javascript">            <span class="comment">// 一些逻辑代码</span></span></span><br><span class="line"><span class="undefined">        &#125;;</span></span><br><span class="line"><span class="javascript">        obj.bigString=<span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">1000</span>).join(<span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">2000</span>).join(<span class="string">"XXXXX"</span>));</span></span><br><span class="line"><span class="javascript">        obj = <span class="literal">null</span>; <span class="comment">//显示中断循环引用</span></span></span><br><span class="line"><span class="undefined">    &#125;;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">"element"</span>&gt;</span>"Click Here"<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure><p>​       另一种方法是通过添加一个闭包，可以避免Javascript对象和DOM对象之间的循环引用。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="built_in">document</span>.write(<span class="string">"Avoiding memory leak via closure by adding another closure"</span>);</span></span><br><span class="line"><span class="javascript">    <span class="built_in">window</span>.onload=<span class="function"><span class="keyword">function</span> <span class="title">outerFunction</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> anotherObj=<span class="function"><span class="keyword">function</span> <span class="title">innerFunction</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">            alert(<span class="string">"Hi! I have avoided the leak"</span>);</span></span><br><span class="line"><span class="javascript">            <span class="comment">// 一些逻辑代码</span></span></span><br><span class="line"><span class="undefined">        &#125;;</span></span><br><span class="line"><span class="javascript">        (<span class="function"><span class="keyword">function</span> <span class="title">anotherInnerFunction</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">var</span> obj = <span class="built_in">document</span>.getElementById(<span class="string">"element"</span>);</span></span><br><span class="line"><span class="undefined">            obj.onclick = anotherObj;</span></span><br><span class="line"><span class="undefined">        &#125;)();</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">"element"</span>&gt;</span>"Click Here"<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure><p>​       第三种方法可以通过添加一个函数来避免闭包，从而防止泄漏。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="built_in">document</span>.write(<span class="string">"Avoid leaks by avoiding closures!"</span>);</span></span><br><span class="line"><span class="javascript">    <span class="built_in">window</span>.onload=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span></span></span><br><span class="line"><span class="undefined">    &#123;</span></span><br><span class="line"><span class="javascript">     <span class="keyword">var</span> obj = <span class="built_in">document</span>.getElementById(<span class="string">"element"</span>);</span></span><br><span class="line"><span class="undefined">     obj.onclick = doesNotLeak;</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="keyword">function</span> <span class="title">doesNotLeak</span>(<span class="params"></span>)</span></span></span><br><span class="line"><span class="undefined">    &#123;</span></span><br><span class="line"><span class="javascript">         <span class="comment">//Your Logic here</span></span></span><br><span class="line"><span class="javascript">         alert(<span class="string">"Hi! I have avoided the leak"</span>); </span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">"element"</span>&gt;</span>"Click Here"<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="二、垃圾回收"><a href="#二、垃圾回收" class="headerlink" title="二、垃圾回收"></a>二、垃圾回收</h2><h3 id="2-1-垃圾收集原理与意义"><a href="#2-1-垃圾收集原理与意义" class="headerlink" title="2.1 垃圾收集原理与意义"></a><strong>2.1 垃圾收集原理与意义</strong></h3><p>​       在C和C++之类的语言中，开发人员的一项基本任务就是手动跟踪内存的使用情况，这是造成很多问题的根源。Javascript具有垃圾收集机制，也就是说，执行环境会负责管理代码执行过程中使用的内存。在编写JavaScript程序时，开发人员不再关心内存使用问题，所需内存的分配以及无用内存的回收完全实现了自动管理。这种垃圾收集机制的原理很简单：找出那些不再继续使用的变量，然后释放其占用的内存。为此，垃圾收集器会按照固定时间间隔（或代码执行中预定的收集时间），周期性地执行这一操作。</p><p>​        局部变量只在函数执行过程中存在。而在这个过程中，会为局部变量在栈（或堆）内存上分配相应的空间，以便存储它们的值。然后在函数中使用这些变量，直至函数执行结束。此时，局部变量就没有存在的必要了，因此可以释放他们的内存以供将来使用。在这种情况下，很容易判断变量是否还有存在的必要；但并非所有情况下就这么容易得出结论。垃圾收集器必须跟踪哪个变量有用哪个变量没用，对于不再有用的对象打上标记，以备将来回收其占用的内存。</p><h3 id="2-2-垃圾收集策略"><a href="#2-2-垃圾收集策略" class="headerlink" title="2.2 垃圾收集策略"></a><strong>2.2 垃圾收集策略</strong></h3><p>​        现在各大浏览器通常采用的垃圾回收策略有两种：<strong>标记清除</strong>和<strong>引用计数</strong>。</p><h4 id="2-2-1-标记清除"><a href="#2-2-1-标记清除" class="headerlink" title="2.2.1 标记清除"></a><strong>2.2.1 标记清除</strong></h4><p>​        JavaScript最常用的垃圾收集方式就是<strong>标记清除</strong>(mark-and-sweep)。当变量进入环境时，就将该变量标记为”进入环境”。从逻辑上讲，永远不能释放进入环境的变量所占用的内存，因为只要执行流进入到相应的环境，就可能会用到它们。而当变量离开环境时，则将其标记为”离开环境“。</p><p>​        垃圾收集器在运行的时候会给存储在内存上的所有变量都加上标记。然后，它会去掉环境中的变量以及被环境中的变量引用的变量的标记。而在此之后再被加上标记的变量将被视为准备删除的变量，原因是环境中的变量已经无法访问到这些变量了。最后，垃圾收集器完成内存清除工作，销毁那些带标记的值并回收他们所占用的内存空间。</p><h4 id="2-2-2-引用计数"><a href="#2-2-2-引用计数" class="headerlink" title="2.2.2 引用计数"></a><strong>2.2.2 引用计数</strong></h4><p>​       这一种垃圾收集策略不太常用，原因在于很容易造成严重的问题：循环引用。引用计数的含义是跟踪记录每个值被引用的次数。当声明了一个变量并将引用类型值赋给该变量时，则这个值得引用次数就是1。如果同一个值又被赋给另一个变量，则该值的引用次数加1。相反如果包含对这个值引用的变量又取到了另外一个值，则这个值的引用次数减1。当这个值的引用次数变成0时，则说明没有办法再访问这个值了，因而就可以将其占用的内存空间回收回来。这样当垃圾收集器下次再运行时，它就会释放那些引用次数为0的值所占用的内存。</p><p>​       引用计数所带来的严重问题是循环引用。循环引用指的是对象A中包含一个指向对象B的指针，而对象B中也包含一个指向对象A的指针；使得引用次数永远不会变成零，不能被垃圾收集器收集，释放其所占用的内存。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">problem</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> objectA = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">    <span class="keyword">var</span> objectB = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">    objectA.someOtherObject = objectB;</span><br><span class="line">    objectB.anotherObject = objectA;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​       在上面的例子中，objectA和objectB通过各自的属性相互引用；也就是说，这两个对象的引用次数都是2。在采用标记清除策略的实现中，由于函数执行后，这两个对象都离开了作用域，因此这种相互引用不是个问题。但在采用引用计数策略的实现中，当函数执行完毕后，objectA和objectB还将继续存在，因为它们的引用次数永远不是0。假如这个函数被重复多次调用，就会导致大量的内存得不到回收。</p><p>​       在IE9之前版本中，有一部分对象并不是原生的Javascript对象。例如，其BOM和DOM中的对象就是使用C++以COM对象的形式实现的，而COM对象的垃圾收集机制采用的就是引用计数策略。因此，即使IE的Javascrip引擎是使用标记清除策略实现的，但Javascript访问的COM对象依然是基于引用计数策略的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> element = <span class="built_in">document</span>.getElementById(<span class="string">"some_element"</span>);</span><br><span class="line"><span class="keyword">var</span> myObj =<span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">myObj.element = element;</span><br><span class="line">element.someObject = myObj;</span><br></pre></td></tr></table></figure><p>​      上面这个例子中，在一个DOM元素(element)与一个原生JavaScript对象(myObj)之间建立了循环引用。其中，变量myObj有一个名为element的属性指向element；而变量element有一个名为someObject的属性回指到myObj。由于循环引用，即使将例子中的DOM从页面中移除，内存也永远不会回收 。</p><p>​       为避免这类问题，最好在不使用它们的时候手工断开原生Javascript与DOM元素之间的连接：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">myObject.element = <span class="literal">null</span>;</span><br><span class="line">element.someObject = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure><p>​       将变量设为null意味着切断变量与它之前引用的值之间的连接。当垃圾收集器下次运行的时候，就会删除这些值并回收它们所占用的内存。IE9+把BOM和DOM对象都转换成了真正的Javascript对象。这样就消除了常见的内存泄露现象。</p><h3 id="2-3-管理内存"><a href="#2-3-管理内存" class="headerlink" title="2.3 管理内存"></a><strong>2.3 管理内存</strong></h3><h4 id="2-3-1-触发垃圾收集"><a href="#2-3-1-触发垃圾收集" class="headerlink" title="2.3.1 触发垃圾收集"></a><strong>2.3.1 触发垃圾收集</strong></h4><p>​        IE的垃圾收集是根据内存分配量进行的，具体就是256个变量、4096个对象（或数组）字面量和数组元素（slot）或则64KB的字符串。达到上述的任何一个临界值，垃圾收集器就会运行。这种实现方式的问题在于，如果一个脚本中包含那么多变量，那么该脚本很可能会在其生命周期中一直保存着那么多的变量。而这样一来，垃圾收集器就不得不频繁地运行，造成严重的性能问题。IE7之后，其Javascript引擎改变了其垃圾收集例程：触发垃圾收集的变量分配、字面量和数组元素的临界值被调整为动态修正。IE7的各项临界初始值和IE6相同，如果垃圾收集例程回收的内存分配量低于15%，这时候把临界条件（变量、字面量、数组元素）加倍，如果例程回收了85%的内存分配量，则将各种临界值重置回默认值。</p><h4 id="2-3-2-管理内存"><a href="#2-3-2-管理内存" class="headerlink" title="2.3.2 管理内存"></a><strong>2.3.2 管理内存</strong></h4><p>​       Javascript在进行内存管理时最主要的问题就是分配给Web浏览器的可用内存量通常要比分配给桌面应的少。这样做的目的是出于安全方面的考虑，目的是防止运行Javascript的网页耗尽全部系统内存而导致系统崩溃。内存限制问题不仅会影响给变量分配的内存，同时还会影响调用栈以及在一个线程中能够同时执行的语句数量。</p><p>​        因此，确保占有最少的内存可以让页面获得更好的性能。而优化内存占用的最佳方式，就是为执行中的代码只保留必要的数据。一旦数据不再有用，最好通过将其值设置为null来解除其引用。这一做法适用于大多数全局变量和全局对象的属性。局部变量会在它们离开执行环境时自动被解除引用。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createPerson</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> localPerson = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">    localPerson.name = name;</span><br><span class="line">    <span class="keyword">return</span> localPerson;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> globalPerson = createPerson(<span class="string">"Nicholas"</span>);</span><br><span class="line">globalPerson = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure><p>​       在这个例子中，由于localPerson在createPerson()函数执行完毕后就离开了其执行环境，因此无需显示地为它解除引用。但对于全局变量globalPerson，则需要我们在不使用它的时候手工为它解除引用。不过，解除一个值得引用并不意味着自动回收该值所占用的内存。解除引用真正的作用是让值脱离执行环境，以便垃圾收集器下次运行时将其回收。</p><h3 id="2-4-减少垃圾收集"><a href="#2-4-减少垃圾收集" class="headerlink" title="2.4 减少垃圾收集"></a><strong>2.4 减少垃圾收集</strong></h3><h4 id="2-4-1-对象object优化"><a href="#2-4-1-对象object优化" class="headerlink" title="2.4.1 对象object优化"></a><strong>2.4.1 对象object优化</strong></h4><p>​        为了最大限度的实现对象的重用，应该像避免使用new语句一样避免使用<code>{}</code>来新建对象。</p><p>　　<code>{&quot;foo&quot; : &quot;bar&quot;}</code>这种方式新建的带属性的对象，常常作为方法的返回值来使用，可是这将会导致过多的内存创建，因此最好的解决办法是：每一次函数调用完成之后，将需要返回的数据放入一个全局的对象中，并返回此全局对象。如果使用这种方式，就意味着每一次方法调用都会导致全局对象内容的修改，这有可能会导致错误的发生。因此，一定要对此全局对象的使用进行详细的注释和说明。</p><p>　　有一种方式能够保证对象（确保对象prototype上没有属性）的重复利用，那就是遍历此对象的所有属性，并逐个删除，最终将对象清理为一个空对象。</p><p>　　<code>cr.wipe(obj)</code>方法就是为此功能而生，代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cr.wipe = <span class="function"><span class="keyword">function</span> (<span class="params">obj</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> p <span class="keyword">in</span> obj) &#123;</span><br><span class="line">         <span class="keyword">if</span> (obj.hasOwnProperty(p))</span><br><span class="line">            <span class="keyword">delete</span> obj[p];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>​        有些时候，你可以使用<code>cr.wipe(obj)</code>方法清理对象，再为obj添加新的属性，就可以达到重复利用对象的目的。虽然通过清空一个对象来获取“新对象”的做法，比简单的通过<code>{}</code>来创建对象要耗时一些，但是在实时性要求很高的代码中，这一点短暂的时间消耗，将会有效的减少垃圾堆积，并且最终避免垃圾回收暂停，这是非常值得的！</p><h4 id="2-4-2-数组优化"><a href="#2-4-2-数组优化" class="headerlink" title="2.4.2 数组优化"></a><strong>2.4.2 数组优化</strong></h4><p>​        将<code>[]</code>赋值给一个数组对象，是清空数组的捷径（例如： arr = [];），但是需要注意的是，这种方式又创建了一个新的空对象，并且将原来的数组对象变成了一小片内存垃圾！实际上，将数组长度赋值为0（arr.length = 0）也能达到清空数组的目的，并且同时能实现数组重用，减少内存垃圾的产生。</p><h4 id="2-4-3-function优化"><a href="#2-4-3-function优化" class="headerlink" title="2.4.3 function优化"></a><strong>2.4.3 function优化</strong></h4><p>​        方法一般都是在初始化的时候创建，并且此后很少在运行时进行动态内存分配，这就使得导致内存垃圾产生的方法，找起来就不是那么容易了。但是从另一角度来说，这更便于我们寻找了，因为只要是动态创建方法的地方，就有可能产生内存垃圾。例如：将方法作为返回值，就是一个动态创建方法的实例。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(</span><br><span class="line">    (<span class="function"><span class="keyword">function</span>(<span class="params">self</span>) </span>&#123;                    </span><br><span class="line">      <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      self.tick();</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;)(<span class="keyword">this</span>), <span class="number">100</span>)</span><br></pre></td></tr></table></figure><p>每过100毫秒调用一次this.tick()，看似没什么问题，但是仔细一琢磨，每一次调用都返回了一个新的方法对象，这就导致了大量的方法对象垃圾！</p><p>　　为了解决这个问题，可以将作为返回值的方法保存起来，例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.tickFunc = (</span><br><span class="line">    <span class="function"><span class="keyword">function</span>(<span class="params">self</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      self.tick();</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">)(<span class="keyword">this</span>);</span><br><span class="line">setTimeout(<span class="keyword">this</span>.tickFunc, <span class="number">100</span>);</span><br></pre></td></tr></table></figure><h2 id="Reference："><a href="#Reference：" class="headerlink" title="Reference："></a>Reference：</h2><p>分别于2018.07.07，2018.07.08 发布于博客园-<a href="https://www.cnblogs.com/princess-knight/p/9277830.html" target="_blank" rel="noopener">垃圾收集</a>、<a href="https://www.cnblogs.com/princess-knight/p/9280500.html" target="_blank" rel="noopener">内存泄漏</a><br><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Memory_Management#Release_when_the_memory_is_not_needed_anymore" target="_blank" rel="noopener">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Memory_Management#Release_when_the_memory_is_not_needed_anymore</a><br><a href="https://www.cnblogs.com/zhwl/p/4664604.html" target="_blank" rel="noopener">https://www.cnblogs.com/zhwl/p/4664604.html</a><br><a href="http://www.ruanyifeng.com/blog/2017/04/memory-leak.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2017/04/memory-leak.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\Blog\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\Blog\assets\js\APlayer.m
      
    
    </summary>
    
    
      <category term="Web" scheme="https://www.knightboy.cn/Blog/tags/Web/"/>
    
  </entry>
  
  <entry>
    <title>跨域问题总结</title>
    <link href="https://www.knightboy.cn/Blog/2018/11/25/%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/"/>
    <id>https://www.knightboy.cn/Blog/2018/11/25/跨域问题总结/</id>
    <published>2018-11-24T16:00:00.000Z</published>
    <updated>2018-11-25T12:23:46.615Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\Blog\assets\css\APlayer.min.css"><script src="\Blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="一、同源与同源策略"><a href="#一、同源与同源策略" class="headerlink" title="一、同源与同源策略"></a>一、同源与同源策略</h3><p>​    我们知道，同源指的是协议、域名、端口号全部相同。同源策略(Same Origin Policy)是一种约定，它是浏览器最核心也是最基本的安全功能，如果缺少了同源策略，则浏览器的正常功能都可能会受到影响。Web是构建在同源策略基础之上的，浏览器只是针对同源策略的一种实现。同源策略是处于对用户安全的考量的，如果缺少了同源的限制，那又怎么能够确定别人的网站始终对你是友好的呢。针对非同源的情况制定了一些限制条件：</p><ol><li>无法读取不同源的<code>Cookie</code>、<code>LocalStorage</code>、<code>indexDB</code>。</li><li>无法获得不同源的DOM。</li><li>不能向不同源的服务器发送Ajax请求。</li></ol><p>　　在浏览器中，<code>&lt;script&gt;</code>、<code>&lt;img&gt;</code>、<code>&lt;iframe&gt;</code>、<code>&lt;link&gt;</code>等标签都可以跨域加载资源，而且不受同源策略的限制。事实上，在大多数情境下，我们经常是需要借用非同源来提供数据的，所以这就要用到跨域方面的技术了。</p><h3 id="二、JSONP"><a href="#二、JSONP" class="headerlink" title="二、JSONP"></a>二、JSONP</h3><p>​    JSONP是指JSON Padding，JSONP是一种非官方跨域数据交换协议，由于<code>script</code>的src属性可以跨域请求，所以JSONP利用的就是浏览器的这个原理，需要通信时，动态插入一个javascript标签。请求的地址一般带有一个<code>callback</code>参数，假设需要请求的地址为<a href="http://localhost:3000?callback=show" target="_blank" rel="noopener">http://localhost:3000?callback=show</a>，服务器返回的代码一般是show()的JSON数据，而show函数恰恰是前端需要用的这个数据的函数。JSONP非常简单易用，自动补全API利用的就是JSONP。</p><p>​        一个简单的例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> script = doxument.createElement(<span class="string">"script"</span>);</span><br><span class="line">script.setAttribute(<span class="string">"type"</span>, <span class="string">"text/javascript"</span>);</span><br><span class="line">script.src=<span class="string">"http://example.com/ip?callback=handleResponse"</span>;</span><br><span class="line"><span class="built_in">document</span>.body.appendChild(script);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handleResponse</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Your public IP address is: '</span>+data.ip);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​       JSONP解决跨域的本质：<code>&lt;script&gt;</code>标签可以请求不同域名下的资源，即<code>&lt;script&gt;</code>请求不受浏览器同源策略的影响。上例中的script会向<a href="http://example.com/" target="_blank" rel="noopener">http://example.com/</a>服务器发送请求，这个请求的url后面带了个callback参数，是用来告诉服务器回调方法的方法名的。因为服务器收到请求后，会把相应的数据写进handleResponse的参数，也就是服务器会返回如下的脚本：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">handleResponse(&#123;</span><br><span class="line">    <span class="string">"ip"</span> : <span class="string">"8.8.8.8"</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>​       这样浏览器通过<code>&lt;script&gt;</code>下载的资源就是上面的脚本了，<code>&lt;script&gt;</code>下载完就会立即执行，也就是说<a href="http://example.com/ip?callback=handleResponse" target="_blank" rel="noopener">http://example.com/ip?callback=handleResponse</a>这个请求返回后就会立即执行上面的脚本代码，而这个脚本代码就是调用回调方法和拿到Json数据了。</p><p>​    我们再来看一个例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//请求代码</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">jsonp</span>(<span class="params">callback</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> script = <span class="built_in">document</span>.createElement(<span class="string">"script"</span>);</span><br><span class="line">        url = <span class="string">`https://localhost:3000?callback=<span class="subst">$&#123;callback&#125;</span>`</span>;</span><br><span class="line">    script.setAttribute(<span class="string">"src"</span>, url);</span><br><span class="line">    <span class="built_in">document</span>.querySelector(<span class="string">"head"</span>).appendChild(script);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">show</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">    concole.log(<span class="string">`学生姓名为: <span class="subst">$&#123;data.name&#125;</span>，年龄为: <span class="subst">$&#123;data.age&#125;</span>，性别为: <span class="subst">$&#123;data.sex&#125;</span>`</span>);</span><br><span class="line">&#125;</span><br><span class="line">jsonp(<span class="string">"show"</span>);</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//响应代码</span></span><br><span class="line"><span class="keyword">const</span> student = &#123;</span><br><span class="line">    name: <span class="string">"Knight"</span>,</span><br><span class="line">    age: <span class="number">19</span>,</span><br><span class="line">    sex: <span class="string">"male"</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> callback = url.parse(req.url, <span class="literal">true</span>).query.callback;</span><br><span class="line">res.writeHead(<span class="number">200</span>,&#123;</span><br><span class="line">    <span class="string">"Content-Type"</span>: <span class="string">"application/json;charset=utf-8"</span></span><br><span class="line">&#125;);</span><br><span class="line">res.end(<span class="string">`<span class="subst">$&#123;callback&#125;</span>(<span class="subst">$&#123;<span class="built_in">JSON</span>.stringify(student)&#125;</span>)`</span>);</span><br></pre></td></tr></table></figure><p><strong>JSONP</strong>有一个很大问题，就是只能进行GET请求。</p><p>{: .notice}</p><h3 id="三、跨域源资源共享-CORS"><a href="#三、跨域源资源共享-CORS" class="headerlink" title="三、跨域源资源共享(CORS)"></a>三、跨域源资源共享(CORS)</h3><p>　　CORS是W3C制定的跨站资源分享标准，可以让AJAX实现跨域访问，定义了在必须访问跨域资源时浏览器与服务器该如何沟通。CORS背后的基本思想，就是使用自定义的HTTP头部让浏览器和服务器进行沟通，从而决定请求或响应应该成功还是失败。</p><p>​        比如一个简单的使用GET或POST的请求，它没有自定义的头部，而主体内容是text/plain。在发送该请求时，需要给它附加一个额外的Origin头部，其中包含请求页面的源信息（协议、域名、端口号），以便服务器根据该头部信息来决定是否给予响应。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Origin: http:<span class="comment">//www.example.com</span></span><br></pre></td></tr></table></figure><p>　　如果服务器认为这个请求可以接受，就在Access-Control-Allow-Origin头部中发回相同的源信息（如果是公共资源，可以发“*”）。例如：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Access-Control-Allow-Origin: http:<span class="comment">//www.example.com</span></span><br></pre></td></tr></table></figure><p>　　如果没有这个头部信息或信息不匹配，浏览器就会驳回请求。正常情况下，浏览器会处理请求。此时，请求和响应都不包含Cookie信息。</p><p>　　<strong>简单请求</strong>的跨域：</p><p>　　请求方式为GET或则POST；</p><p>　　假若请求是POST的话，Content-Type必须为下列之一：</p><blockquote><p>application/x-www-form-urlencoded<br>mutipart/form-data<br>text/plain</p></blockquote><p>　　不含有自定义头；</p><p> 对于简单的跨域只进行一次http请求：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ajaxPost</span>(<span class="params">url, obj, header</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">         <span class="keyword">var</span> xhr=<span class="keyword">new</span> XMLHttpRequest(),</span><br><span class="line">              str = <span class="string">''</span> ;</span><br><span class="line">              keys = <span class="built_in">Object</span>.keys(obj);</span><br><span class="line">         <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>,len=keys.length;i&lt;len;i++) &#123;</span><br><span class="line">             str +=<span class="string">`<span class="subst">$&#123;keys[i]&#125;</span>=<span class="subst">$&#123;obj[keys[i]]&#125;</span>&amp;`</span>;</span><br><span class="line">         &#125;</span><br><span class="line">         str = str.substring(<span class="number">0</span>, str.length - <span class="number">1</span>);</span><br><span class="line">         xhr.open(<span class="string">'post'</span>, url);</span><br><span class="line">         xhr.setRequestHeader(<span class="string">"Content-Type"</span>, <span class="string">"application/x-www-form-urlencoded"</span>);</span><br><span class="line">         <span class="keyword">if</span>(header <span class="keyword">instanceof</span> <span class="built_in">Object</span>) &#123;</span><br><span class="line">             <span class="keyword">for</span>(<span class="keyword">var</span> k <span class="keyword">in</span> header)</span><br><span class="line">                  xhr.setRequestHeader(k, header[k]);</span><br><span class="line">         &#125;</span><br><span class="line">         xhr.send(str);</span><br><span class="line">         xhr.onreadystatechange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">              <span class="keyword">if</span>(xhr.readyState == <span class="number">4</span>) &#123;</span><br><span class="line">                  <span class="keyword">if</span>(xhr.status &gt;= <span class="number">200</span> &amp;&amp; xhr.status &lt; <span class="number">300</span> || xhr.status == <span class="number">304</span>) &#123;</span><br><span class="line">                      resolve(xhr.responseText);</span><br><span class="line">                  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                      reject();</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         </span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line">ajaxPost(<span class="string">"https://localhost:3000?page=cors"</span>, &#123;</span><br><span class="line">        name: <span class="string">"Knight"</span>,</span><br><span class="line">        age: <span class="number">19</span>,</span><br><span class="line">        sex: <span class="string">"male"</span></span><br><span class="line">&#125;).then(<span class="function">(<span class="params">text</span>) =&gt;</span> &#123;<span class="built_in">console</span>.log(text);&#125;,</span><br><span class="line">                ()=&gt;&#123;<span class="built_in">console</span>.log(<span class="string">"请求失败"</span>);&#125;);</span><br><span class="line"><span class="comment">//后端处理</span></span><br><span class="line"><span class="keyword">var</span> postData = <span class="string">""</span>;</span><br><span class="line">req.on(<span class="string">"data"</span>, (data) =&gt; &#123;</span><br><span class="line">    postData += data;</span><br><span class="line">&#125;);</span><br><span class="line">req.on(<span class="string">"end"</span>, () =&gt; &#123;</span><br><span class="line">    postData = querystring.parse(postData);</span><br><span class="line">    res.writeHead(<span class="number">200</span>, &#123;</span><br><span class="line">        <span class="string">"Access-Control-Allow-Origin"</span>: <span class="string">"*"</span>,</span><br><span class="line">        <span class="string">"Content-Type"</span>: <span class="string">"application/json;charset=utf-8"</span></span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">if</span>(postData.name === student.name </span><br><span class="line">       &amp;&amp; <span class="built_in">Number</span>(postData.age) === student.age </span><br><span class="line">       &amp;&amp; postData.sex === student.sex) &#123;</span><br><span class="line">        res.end(<span class="string">`yeah! <span class="subst">$&#123;postData.name&#125;</span> is a good guy!`</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        res.end(<span class="string">"No! a bad guy!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>对于非简单请求来说，需要两次http请求，其中在请求之前有一次预检请求。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ajaxPost</span>(<span class="params">url, obj, header</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">         <span class="keyword">var</span> xhr=<span class="keyword">new</span> XMLHttpRequest(),</span><br><span class="line">              str = <span class="string">''</span> ;</span><br><span class="line">              keys = <span class="built_in">Object</span>.keys(obj);</span><br><span class="line">         <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>,len=keys.length;i&lt;len;i++) &#123;</span><br><span class="line">             str +=<span class="string">`<span class="subst">$&#123;keys[i]&#125;</span>=<span class="subst">$&#123;obj[keys[i]]&#125;</span>&amp;`</span>;</span><br><span class="line">         &#125;</span><br><span class="line">         str = str.substring(<span class="number">0</span>, str.length - <span class="number">1</span>);</span><br><span class="line">         xhr.open(<span class="string">'post'</span>, url);</span><br><span class="line">         xhr.setRequestHeader(<span class="string">"Content-Type"</span>, <span class="string">"application/x-www-form-urlencoded"</span>);</span><br><span class="line">         <span class="keyword">if</span>(header <span class="keyword">instanceof</span> <span class="built_in">Object</span>) &#123;</span><br><span class="line">             <span class="keyword">for</span>(<span class="keyword">var</span> k <span class="keyword">in</span> header)</span><br><span class="line">                  xhr.setRequestHeader(k, header[k]);</span><br><span class="line">         &#125;</span><br><span class="line">         xhr.send(str);</span><br><span class="line">         xhr.onreadystatechange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">              <span class="keyword">if</span>(xhr.readyState == <span class="number">4</span>) &#123;</span><br><span class="line">                  <span class="keyword">if</span>(xhr.status &gt;= <span class="number">200</span> &amp;&amp; xhr.status &lt; <span class="number">300</span> || xhr.status == <span class="number">304</span>) &#123;</span><br><span class="line">                      resolve(xhr.responseText);</span><br><span class="line">                  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                      reject();</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         </span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line">ajaxPost(<span class="string">"https://localhost:3000?page=cors"</span>, &#123;</span><br><span class="line">        name: <span class="string">"Knight"</span>,</span><br><span class="line">        age: <span class="number">19</span>,</span><br><span class="line">        sex: <span class="string">"male"</span></span><br><span class="line">&#125;, &#123;<span class="string">"X-author"</span>: <span class="string">"Knight"</span>&#125;).then(<span class="function">(<span class="params">text</span>) =&gt;</span> &#123;<span class="built_in">console</span>.log(text);&#125;,</span><br><span class="line">                ()=&gt;&#123;<span class="built_in">console</span>.log(<span class="string">"Request Error!"</span>);&#125;);</span><br><span class="line"><span class="comment">//后端处理</span></span><br><span class="line"><span class="keyword">var</span> postData = <span class="string">""</span>;</span><br><span class="line"><span class="keyword">if</span>(req.method == <span class="string">"OPTIONS"</span>) &#123;</span><br><span class="line">    res.writeHead(<span class="number">200</span>, &#123;</span><br><span class="line">        <span class="string">"Access-Control-Max-Age"</span>: <span class="number">3000</span>,</span><br><span class="line">        <span class="string">"Access-Control-Allow-Headers"</span>: <span class="string">"X-author"</span>,</span><br><span class="line">        <span class="string">"Access-Control-Allow-Origin"</span>: <span class="string">"*"</span>,</span><br><span class="line">        <span class="string">"Content-Type"</span>: <span class="string">"application/json;charset=utf-8"</span></span><br><span class="line">    &#125;);</span><br><span class="line">    res.end();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">void</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">req.on(<span class="string">"data"</span>, (data) =&gt; &#123;</span><br><span class="line">    postData += data;</span><br><span class="line">&#125;);</span><br><span class="line">req.on(<span class="string">"end"</span>, () =&gt; &#123;</span><br><span class="line">    postData = querystring.parse(postData);</span><br><span class="line">    res.writeHead(<span class="number">200</span>, &#123;</span><br><span class="line">        <span class="string">"Access-Control-Allow-Origin"</span>: <span class="string">"*"</span>,</span><br><span class="line">        <span class="string">"Content-Type"</span>: <span class="string">"application/json;charset=utf-8"</span></span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">if</span>(postData.name === student.name </span><br><span class="line">       &amp;&amp; <span class="built_in">Number</span>(postData.age) === student.age </span><br><span class="line">       &amp;&amp;  postData.sex === student.sex) &#123;</span><br><span class="line">        res.end(<span class="string">`yeah! <span class="subst">$&#123;postData.name&#125;</span> is a good guy!`</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        res.end(<span class="string">"No! a bad guy!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>　　上面代码中，两个响应头: <code>Access-Control-Allow-Headers</code>，用来指明在实际的请求中，可以使用那些自定义的http请求头；<code>Access-Control-Max-Age</code>，用来指定此次预请求的结果的有效期，在有效期内则不会发出预请求，类似于缓存。</p><h3 id="四、document-domain实现跨域"><a href="#四、document-domain实现跨域" class="headerlink" title="四、document.domain实现跨域"></a><strong>四、document.domain实现跨域</strong></h3><p>　　可以将子域和主域的<code>document.domain</code>设为同一个主域来实现跨域。但前提条件是，这两个域名必须属于同一个基础域名，所用的协议，端口都要一致，否则无法通过<code>document.domain()</code>来进行跨域。</p><p>​    <strong>example 1:</strong></p><p>​    如果想要在你的<a href="http://www.knightboy.cn/a.html">http://www.knightboy.cn/a.html</a>页面里使用<code>&lt;iframe&gt;</code>调用另一个<a href="http://knightboy.cn/b.html" target="_blank" rel="noopener">http://knightboy.cn/b.html</a>页面。这时候你想在a页面里面获取b页面里的DOM，然后进行操作。然后你会发现你不能获得b的DOM。<code>document.getElementById(&quot;myIFrame&quot;).contentWindow.document</code>或<code>window.parent.document.body</code>因为两个窗口不同源而报错。</p><p>​    这时候你只需要在a页面里和b页面里把<code>document.domain</code>设置成相同的值就可以在两个页面里操作DOM了。</p><p>​    <strong>example 2:</strong></p><p>​    如果你在<a href="http://www.knightboy.cn/a.html">http://www.knightboy.cn/a.html</a>页面里写入了<code>document.cookie = &quot;key=hello world&quot;</code>；你在<a href="http://knightboy.cn/b.html" target="_blank" rel="noopener">http://knightboy.cn/b.html</a>页面是拿不到这个cookie的。</p><p>​    原因在于，Cookie是服务器写入浏览器的一小段信息，只有同源的网页才能共享。但是，两个网页一级域名相同，二级域名不同，浏览器允许通过设置<code>document.domain</code>来共享Cookie。另外，服务器也可以在设置Cookie的时候，指定Cookie的所属域名为一级域名。这样的话，二级域名和三级域名不用做任何设置便可以读取这个Cookie。</p><p>​    有一点需要注意的是：<code>document.domain</code>虽然可以读写，但只能设置成自身或者是高一级的父域且主域必须相同。所以<strong>只能解决一级域名相同二级域名不同的跨域问题。</strong>还有就是<strong>document.domain只适用于Cookie和iframe窗口，LocalStorage和IndexDB无法通过这种方法跨域。</strong></p><h3 id="五、window-name跨域"><a href="#五、window-name跨域" class="headerlink" title="五、window.name跨域"></a><strong>五、window.name跨域</strong></h3><p>​    window对象有一个name属性，该属性有个特征：即在一个窗口(window)的生命周期内，窗口载入的所有页面都是共享一个window.name的，每个页面对window.name都有读写的权限，window.name是持久存在一个窗口载入过的所有页面中的，并不会因新页面的载入而进行重置。注意，window.name的值只能是字符串的形式，且这个字符串的大小最大能容许2M左右甚至更大的容量，因浏览器而异，但一般是够用的。</p><p>​    <strong>example 1:</strong></p><p>　　现在在一个浏览器的一个标签页里打开<a href="http://www.knightboy.cn/a.html">http://www.knightboy.cn/a.html</a>页面，你通过location.href = <a href="http://baidu.com/b.html" target="_blank" rel="noopener">http://baidu.com/b.html</a>，在同一个浏览器标签页里打开了不同域名下的页面。这时候这两个页面你可以使用window.name来传递参数。因为window.name指的是浏览器窗口的名字，只要浏览器窗口相同，那么无论在哪个页面里访问都是一样的。</p><p>​    <strong>example 2:</strong></p><p>　　你的<a href="http://www.knightboy.cn/a.html">http://www.knightboy.cn/a.html</a>页面里使用<code>&lt;iframe&gt;</code>调用另一个<a href="http://baidu.com/b.html" target="_blank" rel="noopener">http://baidu.com/b.html</a>页面。这时候你想在a页面里获取b页面里的DOM，然后进行操作。结果会发现不能获得b中的DOM。同样会因为不同源而报错，和上面提到的不同之处就是两个页面的一级域名也不相同。这时候<code>document.domain</code>就解决不了了。</p><p>​    浏览器窗口有window.name属性。这个属性的最大特点就是，无论是否同源，只要在同一个窗口里，前一个网页设置了这个属性，后一个网页可以读取它。比如当在b页面里设定<code>window.name=&quot;hello&quot;</code>，你再返回到a页面，在a页面访问window.name，可以得到hello。这种方法的优点是，window.name容量很大，可以放置非常长的字符串；缺点是必须监听子窗口window.name属性的变化，影响网页性能。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--a.html--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">DOCTYPE</span> <span class="attr">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>跨域<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">        <span class="function"><span class="keyword">function</span> <span class="title">getData</span>(<span class="params"></span>) </span>&#123;<span class="comment">//iframe载入后执行该函数</span></span></span><br><span class="line"><span class="javascript">            <span class="keyword">var</span> iframe = <span class="built_in">document</span>.getElementById(<span class="string">"proxy"</span>);</span></span><br><span class="line"><span class="javascript">            iframe.onload=<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;<span class="comment">//a.html与iframe属于同源了,可以互相访问</span></span></span><br><span class="line"><span class="javascript">                <span class="keyword">var</span> data = iframe.contentWindow.name;</span></span><br><span class="line"><span class="javascript">                <span class="comment">//获取iframe里的window.name，也就是b.html页面给它设置的数据</span></span></span><br><span class="line"><span class="undefined">                alert(data);</span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="javascript">         iframe.src=<span class="string">"data.html"</span>;<span class="comment">//这里的data.html为随便的一个页面，</span></span></span><br><span class="line"><span class="javascript">            <span class="comment">//目的是，使得a.html能访问到iframe里的内容，</span></span></span><br><span class="line"><span class="javascript">            <span class="comment">//也可设置成about:blank</span></span></span><br><span class="line"><span class="undefined">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span>    </span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">iframe</span> <span class="attr">id</span>=<span class="string">"proxy"</span> <span class="attr">src</span>=<span class="string">"http://baidu.com/b.html"</span> </span></span><br><span class="line"><span class="tag">            <span class="attr">style</span>=<span class="string">"display:none"</span> <span class="attr">onload</span>=<span class="string">"getData()"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--b.html--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="built_in">window</span>.name=<span class="string">"this is some data you got from b.html"</span>;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="六、window-postMessage方法跨域"><a href="#六、window-postMessage方法跨域" class="headerlink" title="六、window.postMessage方法跨域"></a><strong>六、window.postMessage方法跨域</strong></h3><p> 　　window.postMessage是一个安全的跨源通信方法。一般情况下，当且仅当执行脚本的页面使用相同的协议（通常都是http）、相同的端口（http默认80，https默认443）和相同的host(两个页面的document.domain的值相同)时，才允许不同页面上的脚本互相访问。<code>window.postMessage</code>提供了一个可控的机制来安全地绕过这一限制，当其在正确使用的情况下。<code>window.postMessage</code>解决的不是浏览器与服务器之间的交互，解决的是浏览器不同窗口之间的通信问题，可以做的就是同步两个网页，当然这两个网页需要属于同一个基础域名。</p><p>　　<strong>example 1:</strong></p><p>　　在a页面打开了一个不同源的b页面，你想要让a和b这两个页面互相通信，例如，a要访问b的<code>LocalStorage</code>。又或者，a页面里的iframe的<code>src</code>是不同源的b页面，你想要让a和b两个页面互相通信，比如依旧是想通过a访问b的<code>LocalStorage</code>。</p><p>　　此时的解决办法是：利用HTML5中新增的<strong>跨文档通信API</strong>，这个API为<code>window</code>对象新增了一个<code>window.postMessage</code>方法，允许跨窗口通信，不论这两个窗口是否同源。a就可以把它的Local Storage发给b，反之，依然可行。</p><p>　　<strong>window.postMessage(message, targetOrigin, [transfer])</strong>三个参数分别表示为：</p><ul><li><code>message</code>是向目标窗口发送的数据；</li><li><code>targetOrigin</code>属性来指定哪些窗口能收到消息事件，其值可以是字符串“*”（表示无限制）或者一个URI（或者说是发送消息的目标域名）；</li><li><code>transfer</code>可选参数，是一串和<code>message</code>同时传递的<code>Transferable</code>对象，这些对象的所有权将被转移给消息的接收方，而发送一方将不再保有所有权。</li></ul><p>　　另外就是，消息的接收方必须有监听事件，否则发送消息时就会报错。</p><p>　　<strong>window.addEventListener(“message”, onmessage);</strong> <code>onmessage</code>接收到的<code>message</code>事件包含三个属性：</p><p>　　data: 从其他<code>window</code>中传递过来的数据。</p><p>　　origin: 调用<code>postMessage</code>时消息发送窗口的<code>origin</code>。这个<code>origin</code>不能保证是该窗口的当前或未来<code>origin</code>，因为<code>postMessage</code>被调用后可能被导航到不同的位置。</p><p>　　source: 对发送消息的窗口对象的引用；您可以使用此来在具有不同origin的两个窗口间建立双向通信。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在a页面执行</span></span><br><span class="line"><span class="keyword">var</span> popUp = <span class="built_in">window</span>.open(<span class="string">'http://localhost:3000'</span>, <span class="string">'title'</span>);</span><br><span class="line">popUp.postMessage(<span class="string">'Hello World!'</span>, <span class="string">'http://localhost:3000'</span>);</span><br></pre></td></tr></table></figure><p>　　同时在<a href="http://localhost:3000" target="_blank" rel="noopener">http://localhost:3000</a>的页面里监听message事件：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">window</span>.addEventListener(<span class="string">'message'</span>, onmessage);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">onmessage</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(event.origin == <span class="string">'http://localhost:8080'</span>) &#123;<span class="comment">//"发送方a的域名"</span></span><br><span class="line">        <span class="built_in">console</span>.log(event.data);<span class="comment">//"Hello World!"</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">console</span>.log(event.data);<span class="comment">//"Hello World!"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们来看另外一个例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//发送端代码</span></span><br><span class="line"><span class="keyword">var</span> domain = <span class="string">"https://localhost"</span>,</span><br><span class="line">    index = <span class="number">1</span>,</span><br><span class="line">    target = <span class="built_in">window</span>.open(<span class="string">`<span class="subst">$&#123;domain&#125;</span>/postmesssage-target.html`</span>);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">send</span>(<span class="params"></span>)  </span>&#123;</span><br><span class="line">    setInterval(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        target.postMessage(<span class="string">`第<span class="subst">$&#123;index++&#125;</span>次数据发送`</span>, domain);</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">"message"</span>, (e)=&gt;&#123;</span><br><span class="line">    <span class="keyword">if</span>(e.data === <span class="string">'ok'</span>)</span><br><span class="line">        send();</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">console</span>.log(e.data);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">//接收端代码</span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">        opener.postMessage(<span class="string">"ok"</span>, opener.domain);</span></span><br><span class="line"><span class="undefined">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span> = <span class="string">"test"</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> test = <span class="built_in">document</span>.querySelector(<span class="string">"#test"</span>);</span></span><br><span class="line"><span class="javascript">    <span class="built_in">window</span>.addEventListener(<span class="string">"message"</span>, (e)=&gt;&#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">if</span>(e.origin !== <span class="string">"http://localhost"</span>) &#123;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">return</span> <span class="keyword">void</span> <span class="number">0</span>;</span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="undefined">        test.innerText = e.data;</span></span><br><span class="line"><span class="undefined">    &#125;);</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><p>　　上面页面中，接受页面已经加载了，这时发送一个消息给发送端，发送端再开始向接收端发送数据。</p><h3 id="七、片段识别符实现跨域"><a href="#七、片段识别符实现跨域" class="headerlink" title="七、片段识别符实现跨域"></a><strong>七、片段识别符实现跨域</strong></h3><p>　　片段识别符就是指URL的#号后面的部分。比如，<a href="http://example.com/x.html#fragment" target="_blank" rel="noopener">http://example.com/x.html#fragment</a>的<code>#fragment</code>。如果只是改变片段标识符，页面不会重复刷新。父窗口和iframe的子窗口之间的通讯或者是<code>window.open</code>打开的子窗口之间的通讯。</p><p>　　父窗口可以把信息，写入子窗口的片段标识符。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> src= originURL + <span class="string">'#'</span> + data;</span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">'myIFrame'</span>).src = src;</span><br></pre></td></tr></table></figure><p>　　子窗口通过监听<code>hashchange</code>事件得到通知。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.onhashchange = checkMessage;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkMessage</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> message = <span class="built_in">window</span>.location.hash;</span><br><span class="line">    <span class="comment">//...  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　同样，子窗口也可以改变父窗口的片段标识符。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">parent.location.href = target + <span class="string">'#'</span> + hash;</span><br></pre></td></tr></table></figure><p>　　总之，父窗口改变子窗口的url的<code>#</code>号后面的部分，后者把要传递的的参数写在#后面，子窗口监听<code>window.onhashchange</code>事件，得到通知，读取<code>window.location.hash</code>解析出有用的数据。同时子窗口也可以向父窗口传递数据。</p><h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><h5 id="2018-07-14-首次发布于博客园"><a href="#2018-07-14-首次发布于博客园" class="headerlink" title="2018.07.14 首次发布于博客园"></a>2018.07.14 首次发布于<a href="https://www.cnblogs.com/princess-knight/p/9311197.html" target="_blank" rel="noopener">博客园</a></h5><p><a href="http://www.ruanyifeng.com/blog/2016/04/same-origin-policy.html" target="_blank" rel="noopener">跨域同源政策及其规避方法</a></p><p><a href="https://www.2cto.com/kf/201610/559565.html" target="_blank" rel="noopener">跨域解决方案大全</a></p><p><a href="https://segmentfault.com/a/1190000012158485" target="_blank" rel="noopener">跨域问题汇总</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\Blog\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\Blog\assets\js\APlayer.m
      
    
    </summary>
    
    
      <category term="前端" scheme="https://www.knightboy.cn/Blog/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>浏览器原理</title>
    <link href="https://www.knightboy.cn/Blog/2018/11/24/%E7%AE%80%E8%BF%B0%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E5%8E%9F%E7%90%86/"/>
    <id>https://www.knightboy.cn/Blog/2018/11/24/简述浏览器渲染原理/</id>
    <published>2018-11-23T16:00:00.000Z</published>
    <updated>2018-11-25T09:40:40.138Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\Blog\assets\css\APlayer.min.css"><script src="\Blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="1-浏览器的高级架构"><a href="#1-浏览器的高级架构" class="headerlink" title="1 浏览器的高级架构"></a>1 浏览器的高级架构</h2><p>​    浏览器的主要组件是：</p><ol><li><strong>用户界面(The user interface)</strong>：这包括地址栏，后退/前进按钮，书签菜单等。浏览器的每个部分都显示除了您看到所请求页面的窗口。</li><li><strong>浏览器引擎(The browser engine)</strong>: 在UI和渲染引擎之间进行编组操作。</li><li><strong>渲染引擎(The rendering engine)</strong>：负责显示请求的内容。例如，如果请求的内容是HTML，则呈现引擎解析HTML和CSS，并在屏幕上显示解析的内容。</li><li><strong>网络(Networking)</strong>：用于网络调用，例如HTTP请求，在独立于平台的界面后面使用不同平台的不同实现。</li><li><strong>UI后端(UI backend)</strong>：用于绘制组合框和窗口等基本小部件。此后端公开了一个非平台特定的通用接口。它下面使用操作系统用户界面方法。</li><li><strong>JavaScript解释器(Javascript interpreter)</strong>。用于解析和执行JavaScript代码。</li><li><strong>数据存储(Data storage)</strong>。这是一个持久层。浏览器可能需要在本地保存各种数据，例如cookie。浏览器还支持存储机制，例如localStorage，IndexedDB，WebSQL和FileSystem。</li></ol><p><img src="https://www.html5rocks.com/en/tutorials/internals/howbrowserswork/layers.png" alt="浏览器组件"></p><center><b>图0 </b>浏览器组件</center><h2 id="2-渲染引擎"><a href="#2-渲染引擎" class="headerlink" title="2 渲染引擎"></a>2 渲染引擎</h2><p>​    不同的浏览器使用不同的渲染引擎：Internet Explorer使用Trident，Firefox使用Gecko，Safari使用WebKit。Chrome和Opera（来自15版）使用Blink，一个WebKit的分支。</p><p>​    WebKit是一个开源渲染引擎，起初是Linux平台的引擎，并由Apple修改以支持Mac和Windows。有关详细信息，请参阅<a href="http://webkit.org/" target="_blank" rel="noopener">webkit.org</a>。    </p><h2 id="3-主流程-The-main-flow"><a href="#3-主流程-The-main-flow" class="headerlink" title="3 主流程(The main flow)"></a>3 主流程(The main flow)</h2><p>​    渲染引擎首先通过网络获得所请求文档的内容，通常以8K分块的方式完成。渲染引擎在获取内容后的基本流程如下：</p><p>​    解析html用以构建DOM树，然后构建Render树(呈现树)，接着布局Render树，最后绘制Render树。流程如<strong>图1</strong>所示。</p><p><img src="https://www.html5rocks.com/en/tutorials/internals/howbrowserswork/flow.png" alt="渲染流程"></p><center><b>图1 </b>渲染引擎基本流程</center><ul><li><p>首先渲染引擎开始解析html文件，并将html标签转化为内容树中的DOM节点。接着，它解析外部CSS文件及Style标签中的样式信息。这些样式信息以及html中的可见性指令将被用来构建另一棵树-Render树。</p></li><li><p>Render树由一些包含有颜色和大小等属性的矩形区域块组成，它们将被按照正确的顺序显示到屏幕上。</p></li><li><p>Render树构建好了之后，将会执行Render树布局，它将确定每个节点在屏幕上的确切坐标。再下一步就是绘制，即遍历Render树，并使用UI后端层绘制每个节点。</p></li><li><p>值得注意的是，这个过程是逐步完成的，为了更好的用户体验，渲染引擎将会尽可能早的将内容呈现到屏幕上，并不会等到所有的html都解析完成之后再去构建和布局Render树。它是边解析边显示，解析一部分内容就显示一部分内容，同时，可能还会通过网络下载其余内容。</p></li></ul><p><img src="https://www.html5rocks.com/en/tutorials/internals/howbrowserswork/webkitflow.png" alt="Webkit引擎解析模式"></p><center><b>图2 </b>Webkit引擎渲染主流程</center><p><img src="https://www.html5rocks.com/en/tutorials/internals/howbrowserswork/image008.jpg" alt="Gecko渲染主流程"></p><center><b>图3 </b>Gecko引擎渲染主流程</center><p>​    从<strong>图2</strong>和<strong>图3</strong>中可以看出，尽管Webkit和Gecko使用的术语稍有不同，他们的主要流程基本相同。Gecko称可见的格式化元素组成的树为frame树，每个元素都是一个frame，Webkit则使用Render树这个名词来命名由渲染对象组成的树。Webkit中元素的定位称为布局，而Gecko中称为回流。Webkit称利用DOM节点及样式信息去构建Render树的过程为attachment，Geoko在html和DOM树之间附加了一层，这层称为内容接收器，相当制造DOM元素的工厂。</p><h2 id="4-浏览器的进程"><a href="#4-浏览器的进程" class="headerlink" title="4 浏览器的进程"></a>4 浏览器的进程</h2><h3 id="4-1-多进程的浏览器"><a href="#4-1-多进程的浏览器" class="headerlink" title="4.1 多进程的浏览器"></a>4.1 多进程的浏览器</h3><ul><li>Browser进程：浏览器的主进程(负责协调、主控)，仅有一个。作用包括：<ul><li>负责浏览器界面显示，与用户交互。如前进，后退，标签，主页等；</li><li>负责各个页面的管理，创建和销毁等其他过程；</li><li>将Renderer进程得到的内存中的Bitmap，绘制到用户界面上；</li><li>网络资源的管理里，下载等；</li></ul></li><li>第三方插件进程：每种类型的插件对应一个进程，仅当使用该插件时才创建，如通过浏览器的扩展程序，使用PDF查看器插件就能显示PDF文档。</li><li>GPU进程：最多一个，用于3D绘制等。</li><li>浏览器渲染进程(浏览器内核，Render进程，内部是多线程)：默认每个Tab页面一个进程，互不影响，主要作用是页面渲染，脚本执行，事件处理等(浏览器也会做些优化，把多个空白Tab页合并成一个进程)。</li></ul><blockquote><p>优势：</p><ul><li>避免单个page crash影响到整个浏览器的运行</li><li>避免第三方插件crash影响到真个浏览器</li><li>多进程充分利用多核优势</li><li>方便使用沙盒模型隔离插件等过程，提高浏览器的生存能力 *</li></ul></blockquote><p><strong>注意：</strong><code>这样做会带来内存的不小消耗，但从长远来看，在浏览器中用空间换时间的策略还是值得的。</code></p><h3 id="4-2-浏览器内核"><a href="#4-2-浏览器内核" class="headerlink" title="4.2 浏览器内核"></a>4.2 浏览器内核</h3><ul><li><strong>GUI渲染线程</strong><ul><li>负责渲染浏览器界面，解析HTML，CSS，构建DOM树和呈现树(Render tree)，布局呈现树和绘制呈现树。</li><li>当界面需要重绘(Repaint)或由于某种操作发生回流(Reflow)时，该线程就会执行。</li><li><strong>注意</strong>：<strong>GUI渲染线程与JS引擎线程是互斥的</strong>，当JS引擎执行时GUI线程就会被挂起(Pending)，GUI更新会被保存在一个队列中等到JS空闲时立即被执行。</li></ul></li><li><strong>JS引擎线程</strong><ul><li>JS引擎线程也称JS内核，负责处理Javascript脚本程序(V8引擎)。</li><li>JS引擎线程负责解析Javascript脚本，运行代码。</li><li>JS引擎一直等待任务队列中任务的回调过程，并加以处理，一个Tab页中有且仅有一个JS线程在运行JS程序。</li><li><strong>注意</strong>：<strong>GUI渲染线程与JS引擎线程是互斥的</strong>，所以如果JS执行时间太长，就会导致页面渲染不连贯，导致页面渲染加载阻塞。(比如在本站打开文章“优化网站性能的35条规则“时偶尔会出现此类情况”)。</li></ul></li><li><strong>事件触发线程</strong><ul><li>归属于浏览器而不是JS引擎，用来控制事件循环。</li><li>当JS引擎执行代码块setTimeout时(也可以来自浏览器内核的其它线程，如鼠标点击、AJax异步请求等)，会将对应任务添加到事件线程中。</li><li>当对应的事件符合触发条件时，该线程会把事件添加到任务队列尾，等待着JS引擎空闲。</li><li><strong>注意</strong>：由于JS单线程的关系，所以在处理任务队列中的任务时必须在JS引擎空闲时按照队列中先后顺序依此执行。</li></ul></li><li><strong>定时触发线程</strong><ul><li>即是<code>setTimeout</code>和<code>setInterval</code>所在的线程。</li><li>浏览器定时计数器并不是由Javascript引擎计数的(因为Javascript引擎是单线程的，处于阻塞状态会影响计时器的准确性)。</li><li>因此通过单独的线程来计时并触发定时(计时完毕后，添加到事件队列中，等待JS引擎空闲时执行)。</li><li><strong>注意</strong>：W3C在HTML标准中规定，规定要求setTimeout中低于4ms的时间间隔算作4ms。</li></ul></li><li><strong>异步http请求线程</strong><ul><li>在<code>XMLHttpRequest</code>在连接后是通过浏览器新开的一个线程请求</li><li>将检测到状态变更时，如果设置有回调函数，异步线程就产生<strong>状态变更事件</strong>，将这个回调再放入事件队列中。再由JavaScript引擎执行。<br><img src="https://user-gold-cdn.xitu.io/2018/1/21/1611938b2d39a5b2?imageslim" alt="浏览器内核"></li></ul></li></ul><h2 id="5-Reference"><a href="#5-Reference" class="headerlink" title="5 Reference"></a>5 Reference</h2><p><a href="https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/" target="_blank" rel="noopener">浏览器的工作原理：新式网络浏览器幕后揭秘</a></p><p><a href="https://juejin.im/post/5a6547d0f265da3e283a1df7" target="_blank" rel="noopener">从浏览器多进程到JS单线程，JS运行机制</a></p><p><a href="http://www.dailichun.com/2018/03/12/whenyouenteraurl.html" target="_blank" rel="noopener">如何由一道题完善自己的前端知识体系</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\Blog\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\Blog\assets\js\APlayer.m
      
    
    </summary>
    
    
      <category term="前端" scheme="https://www.knightboy.cn/Blog/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>优化网站性能的35条规则</title>
    <link href="https://www.knightboy.cn/Blog/2018/11/17/%E4%BC%98%E5%8C%96%E7%BD%91%E7%AB%99%E6%80%A7%E8%83%BD%E7%9A%8435%E6%9D%A1%E8%A7%84%E5%88%99/"/>
    <id>https://www.knightboy.cn/Blog/2018/11/17/优化网站性能的35条规则/</id>
    <published>2018-11-17T13:17:52.000Z</published>
    <updated>2018-11-26T11:24:45.218Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\Blog\assets\css\APlayer.min.css"><script src="\Blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script>        <div id="aplayer-KbbtOsKx" class="aplayer aplayer-tag-marker" style="margin-bottom: 20px;">            <pre class="aplayer-lrc-content"></pre>        </div>        <script>          var ap = new APlayer({            element: document.getElementById("aplayer-KbbtOsKx"),            narrow: false,            autoplay: false,            showlrc: false,            music: {              title: "Unstoppable",              author: "Sia",              url: "Unstoppable.mp3",              pic: "/Blog/2018/11/17/优化网站性能的35条规则/Sia.jpg",              lrc: ""            }          });          window.aplayers || (window.aplayers = []);          window.aplayers.push(ap);        </script><h4 id="最小化HTTP请求次数"><a href="#最小化HTTP请求次数" class="headerlink" title="最小化HTTP请求次数"></a>最小化HTTP请求次数</h4><p>​    最终用户响应时间的80％用于前端。大部分时间都在下载页面中的所有组件：图像，样式表，脚本，Flash等。减少组件数量反过来减少了呈现页面所需的HTTP请求数量。这是更快页面的关键。</p><p>　　减少页面中组件数量的一种方法是简化页面设计。但有没有办法构建内容更丰富的页面，同时还能实现快速响应时间？以下是一些减少HTTP请求数量的技术，同时仍支持丰富的页面设计。</p><p>　　组合文件是一种通过将所有脚本组合到单个脚本中来减少HTTP请求数量的方法，并且类似地将所有CSS组合到单个样式表中。当脚本和样式表在不同页面之间变化时，组合文件更具挑战性，但使这部分发布过程可以缩短响应时间。</p><p>　　<a href="http://alistapart.com/articles/sprites" target="_blank" rel="noopener">CSS Sprites</a>是减少图像请求数量的首选方法。将背景图像合并为单个图像，并使用CSS<code>background-image</code>和<code>background-position</code>属性显示所需的图像片段。</p><p>​    <a href="http://www.w3.org/TR/html401/struct/objects.html#h-13.6" target="_blank" rel="noopener">图像地图</a>将多个图像组合成单个图像。整体大小大致相同，但减少HTTP请求的数量会加快页面的速度。图像映射仅在图像在页面中是连续的时才起作用，例如导航栏。定义图像映射的坐标可能是乏味且容易出错的。使用图像地图进行导航也无法访问，因此不建议使用。</p><p>　　内联图像使用<a href="http://tools.ietf.org/html/rfc2397" target="_blank" rel="noopener"><code>data:</code>URL方案</a>将图像数据嵌入实际页面中。这可以增加HTML文档的大小。将内嵌图像组合到（缓存的）样式表中是一种减少HTTP请求并避免增加页面大小的方法。并非所有主流浏览器都支持内嵌图像。</p><p>　　减少页面中HTTP请求的数量是可以开始的地方。这是提高首次访问者性能的最重要指南。正如Tenni Theurer的博客文章<a href="http://yuiblog.com/blog/2007/01/04/performance-research-part-2/" target="_blank" rel="noopener">浏览器缓存使用 - 暴露！</a>，您网站的每日访问者中有40-60％使用空缓存。让这些首次访问者快速访问页面是获得更好用户体验的关键。</p><h4 id="使用内容分发网络（CDN）"><a href="#使用内容分发网络（CDN）" class="headerlink" title="使用内容分发网络（CDN）"></a>使用内容分发网络（CDN）</h4><p>​    用户与Web服务器的距离会对响应时间产生影响。在多个地理位置分散的服务器上部署内容将使您的页面从用户的角度加载更快。但是你应该从哪里开始呢？</p><p>​    作为实现地理位置分散的内容的第一步，请勿尝试重新设计Web应用程序以在分布式体系结构中工作。根据应用程序的不同，更改体系结构可能包括令人生畏的任务，例如同步会话状态和跨服务器位置复制数据库事务。尝试缩短用户与您的内容之间的距离可能会延迟或永远不会通过此应用程序架构步骤。</p><p>​    请记住，最终用户响应时间的80-90％用于下载页面中的所有组件：图像，样式表，脚本，Flash等。这是<em>性能黄金规则</em>。而不是从重新设计应用程序架构的艰巨任务开始，最好先分散静态内容。这不仅可以缩短响应时间，而且由于内容交付网络，它更容易实现。</p><p>　　内容传送网络（CDN）是分布在多个位置的Web服务器的集合，以更有效地向用户传送内容。选择用于向特定用户传送内容的服务器通常基于网络邻近度的度量。例如，选择具有最少网络跳跃的服务器或具有最快响应时间的服务器。</p><p>　　一些大型互联网公司拥有自己的CDN，但使用CDN服务提供商（如<a href="http://www.akamai.com/" target="_blank" rel="noopener">Akamai Technologies</a>，<a href="http://www.edgecast.com/" target="_blank" rel="noopener">EdgeCast</a>或<a href="http://www.level3.com/index.cfm?pageID=36" target="_blank" rel="noopener">level3）</a>具有成本效益。对于初创公司和私人网站来说，CDN服务的成本可能过高，但随着您的目标受众变得越来越大并变得更加全球化，CDN对于实现快速响应时间是必要的。在Yahoo！中，将静态内容从其应用程序Web服务器移动到CDN（如上所述的第三方以及Yahoo自己的<a href="https://cwiki.apache.org/TS/traffic-server.html" target="_blank" rel="noopener">CDN</a>）的属性将最终用户响应时间提高了20％或更多。切换到CDN是一个相对容易的代码更改，将显著提高您的网站的速度。</p><h4 id="添加Expires或Cache-Control标头"><a href="#添加Expires或Cache-Control标头" class="headerlink" title="添加Expires或Cache-Control标头"></a>添加Expires或Cache-Control标头</h4><p>这条规则有两个方面：</p><ul><li><p>对于静态组件：通过设置远期未来<code>Expires</code>标头实现“永不过期”策略</p></li><li><p>对于动态组件：使用适当的<code>Cache-Control</code>标头来帮助浏览器处理条件请求</p></li></ul><p>​    网页设计越来越丰富，这意味着页面中有更多的脚本，样式表，图像和Flash。您的页面的首次访问者可能必须发出多个HTTP请求，但通过使用Expires标头，您可以使这些组件可缓存。这可以避免后续页面查看中不必要的HTTP请求。Expires头文件通常与图像一起使用，但它们应该用于<em>所有</em>组件，包括脚本，样式表和Flash组件。</p><p>​    浏览器（和代理）使用缓存来减少HTTP请求的数量和大小，从而加快网页加载速度。Web服务器使用HTTP响应中的Expires头来告诉客户端可以缓存组件多长时间。这是一个遥远的未来Expires标题，告诉浏览器这个响应在2010年4月15日之前不会过时。</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Expires</span>: Thu, 15 Apr 2010 20:00:00 GMT</span><br></pre></td></tr></table></figure><p>​       如果您的服务器是Apache，请使用ExpiresDefault指令设置相对于当前日期的到期日期。ExpiresDefault指令的这个示例将Expires日期设置为距请求时间10年。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ExpiresDefault <span class="string">"access plus 10 years"</span></span><br></pre></td></tr></table></figure><p>​    请记住，如果您使用远期的Expires标头，则必须在组件更改时更改组件的文件名。在Yahoo! 我们经常将此步骤作为构建过程的一部分：版本号嵌入在组件的文件名中，例如，<strong><code>yahoo_2.0.6.js</code></strong>。</p><p>​    使用远期Expires标头仅在用户访问过您的网站后才会影响网页浏览量。当用户第一次访问您的站点并且浏览器的缓存为空时，它对HTTP请求的数量没有影响。因此，此性能改进的影响取决于用户使用已准备好的缓存命中您的页面的频率。（“已准备好的缓存”已包含页面中的所有组件。）我们<a href="http://yuiblog.com/blog/2007/01/04/performance-research-part-2/" target="_blank" rel="noopener">在Yahoo!上测量了这一点。</a>并发现带有固定缓存的页面查看次数为75-85％。通过使用远期的Expires标头，您可以增加浏览器缓存的组件数量，并在后续页面视图中重复使用，而无需通过用户的Internet连接发送单个字节。</p><h4 id="使用Gzip组件"><a href="#使用Gzip组件" class="headerlink" title="使用Gzip组件"></a>使用Gzip组件</h4><p>​    通过前端工程师做出的决策，可以显着减少在网络上传输HTTP请求和响应所需的时间。确实，最终用户的带宽速度，互联网服务提供商，与对等交换点的距离等都超出了开发团队的控制范围。但是还有其他变量会影响响应时间。压缩通过减少HTTP响应的大小来减少响应时间。</p><p>从HTTP / 1.1开始，Web客户端表示支持使用HTTP请求中的Accept-Encoding标头进行压缩。</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Accept-Encoding</span>: gzip, deflate</span><br></pre></td></tr></table></figure><p>​    如果Web服务器在请求中看到此标头，它可能会使用客户端列出的方法之一压缩响应。Web服务器通过响应中的Content-Encoding标头向Web客户端通知此情况。</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Content-Encoding</span>: gzip</span><br></pre></td></tr></table></figure><p>​    Gzip是目前最流行，最有效的压缩方法。它由GNU项目开发，并由<a href="http://www.ietf.org/rfc/rfc1952.txt" target="_blank" rel="noopener">RFC 1952</a>标准化。您可能会看到的唯一其他压缩格式是deflate，但效果较差且不太受欢迎。</p><p>​    Gzipping通常将响应大小减少约70％。今天大约90％的互联网流量通过声称支持gzip的浏览器传播。如果你使用Apache，配置gzip的模块取决于你的版本：Apache 1.3使用<a href="http://sourceforge.net/projects/mod-gzip/" target="_blank" rel="noopener">mod_gzip</a>而Apache 2.x使用<a href="http://httpd.apache.org/docs/2.0/mod/mod_deflate.html" target="_blank" rel="noopener">mod_deflate</a>。</p><p>​    浏览器和代理存在已知问题，这些问题可能导致浏览器期望的内容与压缩内容相关的内容不匹配。幸运的是，随着旧浏览器的使用逐渐减少，这些边缘情况正在逐渐减少。Apache模块通过自动添加适当的Vary响应头来提供帮助。</p><p>​    服务器根据文件类型选择gzip的内容，但通常在他们决定压缩的内容方面受到限制。大多数网站都会gzip他们的HTML文档。gzip你的脚本和样式表也是值得的，但很多网站都错过了这个机会。实际上，压缩包括XML和JSON在内的任何文本响应都是值得的。不应对图像和PDF文件进行gzip压缩，因为它们已经过压缩。试图对它们进行gzip不仅浪费CPU，而且可能会增加文件大小。</p><p>​    尽可能多地压缩文件类型是减轻页面重量和加速用户体验的简便方法。</p><h4 id="将CSS样式表放在头部"><a href="#将CSS样式表放在头部" class="headerlink" title="将CSS样式表放在头部"></a>将CSS样式表放在头部</h4><p>​    在研究Yahoo!的性能时，我们发现将样式表移动到文档HEAD会使页面<em>看起来</em>加载速度更快。这是因为将样式表放在HEAD中允许页面逐步呈现。</p><p>​    关注性能的前端工程师希望页面逐步加载; 也就是说，我们希望浏览器尽快显示它拥有的任何内容。这对于具有大量内容的页面和对较慢Internet连接的用户尤其重要。为用户提供视觉反馈（例如进度指示器）的重要性已得到很好的研究和<a href="http://www.useit.com/papers/responsetime.html" target="_blank" rel="noopener">记录</a>。在我们的例子中，HTML页面是进度指示器！当浏览器逐步加载页面时，标题，导航栏，顶部的徽标等都作为等待页面的用户的视觉反馈。这改善了整体用户体验。</p><p>​    将样式表放在文档底部附近的问题是它禁止在许多浏览器（包括Internet Explorer）中逐行渲染。这些浏览器会阻止渲染，以避免在样式发生变化时重绘页面元素。用户查看空白页面时卡住了。</p><p>​    <a href="http://www.w3.org/TR/html4/struct/links.html#h-12.3" target="_blank" rel="noopener">HTML规范</a>明确指出，样式表是被包括在网页的HEAD：“与A，[LINK]可以仅出现在一个文档的HEAD部分，尽管它可能出现任意次数”。这些替代品，空白的白色屏幕或无风格内容的闪光都是值得冒险的。最佳解决方案是遵循HTML规范并在文档HEAD中加载样式表。</p><h4 id="将JavaScript脚本放在底部"><a href="#将JavaScript脚本放在底部" class="headerlink" title="将JavaScript脚本放在底部"></a>将JavaScript脚本放在底部</h4><p>​    脚本引起的问题是它们阻止了并行下载。<a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec8.html#sec8.1.4" target="_blank" rel="noopener">HTTP / 1.1规范</a>建议的浏览器下载不超过两种组分在每主机名平行。如果您从多个主机名提供图像，则可以并行执行两次以上的下载。但是，在下载脚本时，即使在不同的主机名上，浏览器也不会启动任何其他下载。</p><p>​    在某些情况下，将脚本移到底部并不容易。例如，如果脚本用于<code>document.write</code>插入页面内容的一部分，则无法在页面中向下移动。可能还存在范围问题。在许多情况下，有办法解决这些问题。</p><p>​    经常出现的另一种建议是使用延迟脚本。该<code>DEFER</code>属性表明该脚本不包含document.write，并且是浏览器可以继续呈现的线索。不幸的是，Firefox不支持该<code>DEFER</code>属性。在Internet Explorer中，脚本可能会延迟，但不是所需的。如果可以延迟脚本，也可以将其移动到页面底部。这将使您的网页加载速度更快。</p><h4 id="避免使用CSS中的expressions"><a href="#避免使用CSS中的expressions" class="headerlink" title="避免使用CSS中的expressions"></a>避免使用CSS中的expressions</h4><p>​    CSS表达式是一种动态设置CSS属性的强大（且危险）方法。从版本5开始，它们在Internet Explorer中受支持，但从<a href="http://msdn.microsoft.com/en-us/library/ms537634%28VS.85%29.aspx" target="_blank" rel="noopener">IE8开始不推荐使用</a>。例如，可以使用CSS表达式将背景颜色设置为每小时交替：  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">background-color: expression((<span class="keyword">new</span> <span class="built_in">Date</span>()).getHours()%<span class="number">2</span> ? <span class="string">"#B8D4FF"</span> : <span class="string">"#F08A00"</span>);</span><br></pre></td></tr></table></figure><p>​    如此处所示，该<code>expression</code>方法接受JavaScript表达式。CSS属性设置为评估JavaScript表达式的结果。<code>expression</code>其他浏览器会忽略该方法，因此在Internet Explorer中设置属性以在跨浏览器创建一致体验时非常有用。</p><p>​    表达式的问题在于它们的评估频率高于大多数人的预期。它们不仅在页面呈现和调整大小时进行评估，而且在页面滚动时甚至在用户将鼠标移动到页面上时进行评估。在CSS表达式中添加计数器可以让我们跟踪CSS表达式的计算时间和频率。在页面上移动鼠标可以轻松生成10,000多个评估。</p><p>​    减少CSS表达式求值次数的一种方法是使用一次性表达式，其中第一次计算表达式时，它将style属性设置为显式值，这将替换CSS表达式。如果必须在页面的整个生命周期中动态设置样式属性，则使用事件处理程序而不是CSS表达式是另一种方法。如果必须使用CSS表达式，请记住它们可能会被评估数千次，并可能影响页面的性能。</p><h4 id="将JavaScript和CSS独立成外部文件"><a href="#将JavaScript和CSS独立成外部文件" class="headerlink" title="将JavaScript和CSS独立成外部文件"></a>将JavaScript和CSS独立成外部文件</h4><p>​    其中许多性能规则都涉及外部组件的管理方式。但是，在出现这些考虑因素之前，您应该提出一个更基本的问题：JavaScript和CSS是否应该包含在外部文件中，还是内嵌在页面中？</p><p>​    在现实世界中使用外部文件通常会产生更快的页面，因为浏览器会缓存JavaScript和CSS文件。每次请求HTML文档时，都会下载HTML文档中内联的JavaScript和CSS。这减少了所需的HTTP请求数，但增加了HTML文档的大小。另一方面，如果JavaScript和CSS位于浏览器缓存的外部文件中，则HTML文档的大小会减少，而不会增加HTTP请求的数量。</p><p>​    因此，关键因素是外部JavaScript和CSS组件相对于请求的HTML文档数量的缓存频率。这个因素虽然难以量化，但可以使用各种指标进行衡量。如果您站点上的用户每个会话有多个页面查看，并且您的许多页面重复使用相同的脚本和样式表，则缓存的外部文件可能会带来更大的潜在好处。</p><p>​    许多网站都处于这些指标的中间。对于这些站点，最佳解决方案通常是将JavaScript和CSS部署为外部文件。内联的唯一例外是主页，例如<a href="http://www.yahoo.com/" target="_blank" rel="noopener">Yahoo！的首页</a>和<a href="http://my.yahoo.com/" target="_blank" rel="noopener">My Yahoo! </a>。每个会话具有很少（可能只有一个）页面视图的主页可能会发现内联JavaScript和CSS会导致更快的最终用户响应时间。</p><p>​    对于通常是许多页面视图中的第一个的首页，有一些技术可以利用内联提供的HTTP请求的减少，以及通过使用外部文件实现的缓存优势。其中一种技术是在首页中内联JavaScript和CSS，但在页面加载完成后动态下载外部文件。后续页面将引用应该已存在于浏览器缓存中的外部文件。</p><h4 id="减少DNS查询"><a href="#减少DNS查询" class="headerlink" title="减少DNS查询"></a>减少DNS查询</h4><p>　　域名系统（DNS）将主机名映射到IP地址，就像电话簿将人们的姓名映射到他们的电话号码一样。当您在浏览器中键入<a href="http://www.yahoo.com" target="_blank" rel="noopener">www.yahoo.com</a> 时，浏览器联系的DNS解析器将返回该服务器的IP地址。DNS有成本。DNS通常需要20-120毫秒才能查找给定主机名的IP地址。在DNS查找完成之前，浏览器无法从此主机名下载任何内容。</p><p>　　缓存DNS查找以获得更好的性能。此缓存可以在由用户的ISP或局域网维护的特殊缓存服务器上进行，但在单个用户的计算机上也存在缓存。DNS信息保留在操作系统的DNS缓存中（Microsoft Windows上的“DNS客户端服务”）。大多数浏览器都有自己的缓存，与操作系统的缓存分开。只要浏览器将DNS记录保存在自己的缓存中，它就不会因操作系统请求记录而烦恼。</p><p>　　默认情况下，Internet Explorer会将DNS查找缓存30分钟，具体 <code>DnsCacheTimeout</code>取决于注册表设置。Firefox将DNS查找缓存1分钟，由<code>network.dnsCacheExpiration</code>配置设置控制。（Fasterfox将此更改为1小时。）</p><p>　　当客户端的DNS缓存为空（对于浏览器和操作系统）时，DNS查找的数量等于网页中唯一主机名的数量。这包括页面的URL，图像，脚本文件，样式表，Flash对象等中使用的主机名。减少唯一主机名的数量可减少DNS查找的数量。</p><p>　　减少唯一主机名的数量有可能减少页面中发生的并行下载量。避免DNS查找会缩短响应时间，但减少并行下载可能会缩短响应时间。我的准则是将这些组件分成至少两个但不超过四个主机名。这导致在减少DNS查找和允许高度并行下载之间的良好折衷。</p><h4 id="压缩JavaScript和CSS-包括内联-lt-script-gt-和-lt-style-gt"><a href="#压缩JavaScript和CSS-包括内联-lt-script-gt-和-lt-style-gt" class="headerlink" title="压缩JavaScript和CSS(包括内联&lt;script&gt;和&lt;style&gt;)"></a>压缩JavaScript和CSS(包括内联<code>&lt;script&gt;</code>和<code>&lt;style&gt;</code>)</h4><p>　　压缩是从代码中删除不必要的字符以减小其大小从而改善加载时间的做法。压缩代码时，将删除所有注释，以及不需要的空格字符（空格，换行符和制表符）。在JavaScript的情况下，这改善了响应时间性能，因为下载文件的大小减小了。用于压缩JavaScript代码的两种流行工具是<a href="http://crockford.com/javascript/jsmin" target="_blank" rel="noopener">JSMin</a>和<a href="https://developer.yahoo.com/yui/compressor/" target="_blank" rel="noopener">YUI Compressor</a>。YUI压缩器也可以压缩CSS。</p><p>　　混淆是可以应用于源代码的替代优化。它比压缩更复杂，因此更容易因混淆步骤本身而产生错误。在对美国十大顶级网站的调查中，压缩规模缩小了21％，而混淆缩小了25％。尽管混淆具有更高的大小缩减，但压缩JavaScript的风险较小。</p><p>　　除了压缩外部脚本和样式之外，内联<code>&lt;script&gt;</code>和<code>&lt;style&gt;</code>块也可以并且也应该压缩。即使你gzip你的脚本和样式，压缩它们仍然会减小5％或更多的大小。随着JavaScript和CSS的使用和大小的增加，压缩代码所节省的成本也会增加。</p><h4 id="避免重定向"><a href="#避免重定向" class="headerlink" title="避免重定向"></a>避免重定向</h4><p>　　使用301和302状态代码完成重定向。以下是301响应中HTTP标头的示例：</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 <span class="number">301</span> Moved Permanently</span><br><span class="line"><span class="attribute">Location</span>: http://example.com/newuri</span><br><span class="line"><span class="attribute">Content-Type</span>: text/html</span><br></pre></td></tr></table></figure><p>　　浏览器自动将用户带到该<code>Location</code>字段中指定的URL 。重定向所需的所有信息都在标题中。响应的主体通常是空的。尽管有其名称，但实际上不会缓存301或302响应，除非其他标题（例如<code>Expires</code>或<code>Cache-Control</code>表示它应该是）。元刷新标记和JavaScript是将用户定向到不同URL的其他方法，但如果必须进行重定向，则首选技术是使用标准3xx HTTP状态代码，主要是为了确保后退按钮正常工作。</p><p>　　要记住的主要事情是重定向会降低用户体验。在用户和HTML文档之间插入重定向会延迟页面中的所有内容，因为页面中的任何内容都无法呈现，并且在HTML文档到达之前不会开始下载任何组件。</p><p>　　最浪费的重定向之一经常发生，Web开发人员通常不了解它。当URL中缺少尾部斜杠（/）时会发生这种情况。例如，转到<a href="http://astrology.yahoo.com/astrology" target="_blank" rel="noopener">http://astrology.yahoo.com/astrology</a>会产生301响应，其中包含重定向到<a href="http://astrology.yahoo.com/astrology/" target="_blank" rel="noopener">http://astrology.yahoo.com/astrology/</a>（注意添加的尾部斜杠）。如果您使用的是Apache处理程序，则可以使用<code>Alias</code>或<code>mod_rewrite</code>或 <code>DirectorySlash</code>指令在Apache中修复此问题。</p><p>　　将旧网站连接到新网站是重定向的另一种常见用途。其他包括连接网站的不同部分并基于特定条件（浏览器类型，用户帐户类型等）指导用户。使用重定向连接两个网站很简单，只需要很少的额外编码。虽然在这些情况下使用重定向会降低开发人员的复杂性，但会降低用户体验。使用重定向的替代方法包括使用<code>Alias</code>以及<code>mod_rewrite</code>两个代码路径是否托管在同一服务器上。如果域名更改是使用重定向的原因，则另一种方法是创建CNAME（创建从一个域名指向另一个域名的别名的DNS记录）与<code>Alias</code>或组合<code>mod_rewrite</code>。</p><h4 id="删除重复的脚本"><a href="#删除重复的脚本" class="headerlink" title="删除重复的脚本"></a>删除重复的脚本</h4><p>　　在一个页面中两次包含相同的JavaScript文件会损害性能。这并不像你想象的那么不寻常。对美国十大顶级网站的评论显示，其中两个网站包含重复的脚本。两个主要因素会增加脚本在单个网页中重复的几率：团队规模和脚本数量。当它发生时，重复的脚本会通过创建不必要的HTTP请求和浪费的JavaScript执行来损害性能。</p><p>　　不必要的HTTP请求在Internet Explorer中发生，但在Firefox中不发生。在Internet Explorer中，如果外部脚本包含两次且不可缓存，则在页面加载期间会生成两个HTTP请求。即使脚本是可缓存的，当用户重新加载页面时也会发生额外的HTTP请求。</p><p>　　除了生成浪费的HTTP请求之外，还浪费了多次评估脚本的时间。无论脚本是否可缓存，这种冗余的JavaScript执行都会在Firefox和Internet Explorer中执行。</p><p>　　避免意外包含相同脚本两次的一种方法是在模板系统中实现脚本管理模块。包含脚本的典型方法是在HTML页面中使用SCRIPT标记。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span> =<span class="string">"text/javascript"</span> <span class="attr">src</span> =<span class="string">"menu_1.0.17.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>　　PHP中的另一种选择是创建一个名为insertScript的函数。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?</span> php insertScript（<span class="string">"menu.js"</span>）<span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>　　除了防止多次插入相同的脚本之外，此函数还可以处理脚本的其他问题，例如依赖性检查和向脚本文件名添加版本号以支持远期的Expires头。</p><h4 id="配置实体标记ETag"><a href="#配置实体标记ETag" class="headerlink" title="配置实体标记ETag"></a>配置实体标记ETag</h4><p>　　实体标记（ETag）是Web服务器和浏览器用于确定浏览器缓存中的组件是否与源服务器上的组件匹配的机制。（“实体”是另一个词“组件”：图像，脚本，样式表等）。添加ETag以提供验证比上次修改日期更灵活的实体的机制。ETag是唯一标识组件的特定版本的字符串。唯一的格式约束是引用字符串。源服务器使用<code>ETag</code>响应头指定组件的ETag 。</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 <span class="number">200</span> OK</span><br><span class="line"><span class="attribute">Last-Modified</span>: Tue, 12 Dec 2006 03:03:59 GMT</span><br><span class="line"><span class="attribute">ETag</span>: "10c24bc-4ab-457e1c1f"</span><br><span class="line"><span class="attribute">Content-Length</span>: 12195</span><br></pre></td></tr></table></figure><p>　　之后，如果浏览器必须验证组件，它将使用<code>If-None-Match</code>标头将ETag传递回原始服务器。如果ETag匹配，则返回304状态代码，从而将响应减少12195字节。</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GET</span> <span class="string">/i/yahoo.gif</span> HTTP/1.1</span><br><span class="line"><span class="attribute">Host</span>: us.yimg.com</span><br><span class="line"><span class="attribute">If-Modified-Since</span>: Tue, 12 Dec 2006 03:03:59 GMT</span><br><span class="line"><span class="attribute">If-None-Match</span>: "10c24bc-4ab-457e1c1f"</span><br><span class="line">HTTP/1.1 <span class="number">304</span> Not Modified</span><br></pre></td></tr></table></figure><p>　　ETag的问题在于它们通常使用属性构建，这些属性使它们对托管站点的特定服务器是唯一的。当浏览器从一个服务器获取原始组件并稍后尝试在不同服务器上验证该组件时，ETag将不匹配，这种情况在使用服务器集群处理请求的网站上非常常见。默认情况下，Apache和IIS都在ETag中嵌入数据，这大大降低了在具有多个服务器的网站上成功进行有效性测试的几率。</p><p>　　Apache 1.3和2.x的ETag格式是<code>inode-size-timestamp</code>。虽然给定文件可以跨多个服务器驻留在同一目录中，并且具有相同的文件大小，权限，时间戳等，但它的inode在服务器与下一个服务器之间是不同的。</p><p>　　IIS 5.0和6.0与ETag有类似的问题。IIS上ETag的格式是<code>Filetimestamp:ChangeNumber</code>。<code>ChangeNumber</code>是用于跟踪IIS配置更改的计数器。后面整个网站的所有IIS服务器<code>ChangeNumber</code>是相同这是不太可能的。</p><p>　　最终结果是Apache和IIS生成的ETag对于完全相同的组件从一台服务器到另一台服务器不匹配。如果ETag不匹配，则用户不会收到ETag设计的小的，快速的304响应; 相反，他们将获得正常的200响应以及组件的所有数据。如果您只在一台服务器上托管您的网站，这不是问题。但是，如果您有多个服务器托管您的网站，并且您正在使用具有默认ETag配置的Apache或IIS，则您的用户正在变慢页面，您的服务器负载更高，您正在消耗更大的带宽，并且代理服务器没有有效地缓存您的内容。即使您的组件具有远期<code>Expires</code>标头，每当用户点击重新加载或刷新时，仍会发出条件GET请求。</p><p>　　如果您没有利用ETag提供的灵活验证模型，最好只删除ETag。该<code>Last-Modified</code>头验证基于对组件的时间戳。删除ETag会减少响应和后续请求中HTTP标头的大小。此<a href="http://support.microsoft.com/?id=922733" target="_blank" rel="noopener">Microsoft支持文章</a>介绍了如何删除ETag。在Apache中，只需将以下行添加到Apache配置文件即可：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FileETag none</span><br></pre></td></tr></table></figure><h4 id="使Ajax可以缓存"><a href="#使Ajax可以缓存" class="headerlink" title="使Ajax可以缓存"></a>使Ajax可以缓存</h4><p>　　Ajax的一个优点是它为用户提供即时反馈，因为它从后端Web服务器异步请求信息。但是，使用Ajax并不能保证用户不会在等待那些异步JavaScript和XML响应返回时大拇指。在许多应用程序中，用户是否保持等待取决于Ajax的使用方式。例如，在基于Web的电子邮件客户端中，用户将一直等待Ajax请求的结果，以查找符合其搜索条件的所有电子邮件。重要的是要记住“异步”并不意味着“瞬时”。</p><p>​    为了提高性能，优化这些Ajax响应非常重要。提高Ajax性能的最重要方法是使响应可缓存，如<a href="https://developer.yahoo.com/performance/rules.html?guccounter=1#expires" target="_blank" rel="noopener">添加Expires或Cache-controll标头中所述</a>。其他一些规则也适用于Ajax：</p><ul><li><a href="https://developer.yahoo.com/performance/rules.html?guccounter=1#gzip" target="_blank" rel="noopener">Gzip组件</a></li><li><a href="https://developer.yahoo.com/performance/rules.html?guccounter=1#dns_lookups" target="_blank" rel="noopener">减少DNS查找</a></li><li><a href="https://developer.yahoo.com/performance/rules.html?guccounter=1#minify" target="_blank" rel="noopener">压缩JavaScript</a></li><li><a href="https://developer.yahoo.com/performance/rules.html?guccounter=1#redirects" target="_blank" rel="noopener">避免重定向</a></li><li><a href="https://developer.yahoo.com/performance/rules.html?guccounter=1#etags" target="_blank" rel="noopener">配置ETag</a></li></ul><p>　　我们来看一个例子。Web 2.0电子邮件客户端可能使用Ajax下载用户的通讯簿以进行自动完成。如果用户自上次使用电子邮件Web应用程序以来未修改过她的地址簿，则可以从缓存中读取先前的地址簿响应，如果该Ajax响应可以使用将来的Expires或Cache-Control标头进行缓存。必须通知浏览器何时使用先前缓存的地址簿响应而不是请求新的地址簿响应。这可以通过向地址簿Ajax URL添加时间戳来完成，该时间戳指示用户上次修改其地址簿的时间，例如，<code>&amp;t=1190241612</code>。如果自上次下载后地址簿尚未被修改，则时间戳将相同，并且将从浏览器的缓存中读取地址簿，从而消除额外的HTTP往返。如果用户修改了地址簿，则时间戳确保新URL与缓存的响应不匹配，浏览器将请求更新的地址簿条目。</p><p>　　即使您的Ajax响应是动态创建的，并且可能仅适用于单个用户，它们仍然可以缓存。这样做可以使您的Web 2.0应用程序更快。</p><h4 id="尽早清除缓存"><a href="#尽早清除缓存" class="headerlink" title="尽早清除缓存"></a>尽早清除缓存</h4><p>　　当用户请求页面时，后端服务器可能需要200到500毫秒才能将HTML页面拼接在一起。在此期间，浏览器在等待数据到达时处于空闲状态。在PHP中，您有函数<a href="http://php.net/flush" target="_blank" rel="noopener">flush()</a>。它允许您将部分准备好的HTML响应发送到浏览器，以便浏览器可以在后端忙于HTML页面的其余部分时开始获取组件。这种好处主要出现在繁忙的后端或轻量级前端。</p><p>　　考虑刷新的好地方就在HEAD之后，因为头部的HTML通常更容易生成，并且它允许您包含任何CSS和JavaScript文件，以便浏览器在后端处理时并行地开始获取。</p><p>例：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- css,js --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="php"><span class="meta">&lt;?php</span> flush();<span class="meta">?&gt;</span></span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- content --&gt;</span></span><br></pre></td></tr></table></figure><p>　　<a href="http://search.yahoo.com/" target="_blank" rel="noopener">雅虎 搜索</a>开创性研究和真实用户测试，以证明使用此技术的好处。</p><h4 id="使用GET进行Ajax请求"><a href="#使用GET进行Ajax请求" class="headerlink" title="使用GET进行Ajax请求"></a>使用GET进行Ajax请求</h4><p>　　在<a href="http://mail.yahoo.com/" target="_blank" rel="noopener">雅虎 邮件</a>团队发现，在使用时<code>XMLHttpRequest</code>，POST在浏览器中实现为两步过程：首先发送标头，然后发送数据。因此最好使用GET，它只需要一个TCP数据包发送（除非你有很多cookie）。IE中的最大URL长度为<strong>2K</strong>，因此如果发送的数据超过<strong>2K</strong>，则可能无法使用GET。</p><p>　　一个有趣的副作用是没有实际发布任何数据的POST就像GET一样。根据<a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec9.html" target="_blank" rel="noopener">HTTP规范</a>，GET用于检索信息，因此当您仅请求数据时，使用GET是有意义的（语义上），而不是将数据发送到服务器端存储。</p><h4 id="延迟加载组件"><a href="#延迟加载组件" class="headerlink" title="延迟加载组件"></a>延迟加载组件</h4><p>　　您可以仔细查看您的页面并问自己：“页面最初渲染必要的是什么？”。其余的内容和组件可以等待。</p><p>　　JavaScript是在onload事件之前和之后拆分的理想候选者。例如，如果您有执行拖放和动画的JavaScript代码和库，则可以等待，因为在初始渲染之后拖动页面上的元素。其他寻找后期加载候选者的地方包括隐藏内容（用户操作后显示的内容）和首屏下方的图像。</p><p>　　帮助您完成工作的工具：<a href="https://developer.yahoo.com/yui/imageloader/" target="_blank" rel="noopener">YUI Image Loader</a>允许您将图像延迟到折叠下方，<a href="https://developer.yahoo.com/yui/get/" target="_blank" rel="noopener">YUI Get实用程序</a>是一种简单的方法，可以动态地包含JS和CSS。在野外的例子看看<a href="http://www.yahoo.com/" target="_blank" rel="noopener">雅虎！</a>打开Firebug网络面板的<a href="http://www.yahoo.com/" target="_blank" rel="noopener">主页</a>。</p><p>　　当性能目标与其他Web开发最佳实践一致时，这是很好的。在这种情况下，渐进增强的想法告诉我们，JavaScript在受支持时可以改善用户体验，但您必须确保即使没有JavaScript也能正常工作。因此，在确保页面正常工作之后，您可以使用一些后期加载的脚本来增强它，这些脚本可以为您提供更多的花俏功能，例如拖放和动画。</p><h4 id="预加载组件"><a href="#预加载组件" class="headerlink" title="预加载组件"></a>预加载组件</h4><p>　　预加载可能看起来与延迟加载相反，但它实际上有不同的目标。通过预加载组件，您可以利用浏览器空闲的时间并请求将来需要的组件（如图像，样式和脚本）。这样，当用户访问下一页时，您可以将大部分组件放在缓存中，并且您的页面将为用户加载更快。</p><p>　　实际上有几种类型的预加载：</p><ul><li><strong>无条件</strong>预加载 - 一旦onload触发，你就可以继续获取一些额外的组件。请访问google.com，了解如何请求加载精灵图片。google.com主页上不需要此精灵图片，但在连续搜索结果页面上需要此精灵图片。</li><li><strong>条件</strong>预加载 - 基于用户操作，您可以进行有根据的猜测，即用户前进的位置并相应地预加载。在<a href="http://search.yahoo.com/" target="_blank" rel="noopener">search.yahoo.com</a>上，您可以看到在开始输入输入框后如何请求一些额外的组件。</li><li><strong>预期的</strong>预加载 - 在启动重新设计之前提前预加载。经常在重新设计之后听到：“新网站很酷，但比以前慢”。部分问题可能是用户使用完整缓存访问旧网站，但新网站始终是空缓存体验。您可以通过在启动重新设计之前预加载某些组件来缓解此副作用。您的旧站点可以使用浏览器空闲的时间并请求新站点将使用的图像和脚本</li></ul><h4 id="减少DOM元素的数量"><a href="#减少DOM元素的数量" class="headerlink" title="减少DOM元素的数量"></a>减少DOM元素的数量</h4><p>　　复杂页面意味着要下载更多字节，这也意味着JavaScript中的DOM访问速度更慢。例如，当您想要添加事件处理程序时，如果在页面上循环遍历500或5000个DOM元素，则会有所不同。</p><p>　　大量的DOM元素可能是一种通症，即应该通过页面标记来改进，而不必删除内容。您是否使用嵌套表进行布局？您是否只是为了解决布局问题而投入更多<code>&lt;div&gt;</code>？也许有一种更好，语义更正确的标记方式。</p><p>　　<a href="https://developer.yahoo.com/yui/" target="_blank" rel="noopener">YUI CSS实用程序</a> 提供了很好的布局帮助：grids.css可以帮助您完成整体布局，fonts.css和reset.css可以帮助您去除浏览器的默认格式。这是一个重新开始并考虑标记的机会，例如，<code>&lt;div&gt;</code>只有在语义上有意义时才使用s，而不是因为它呈现新行。</p><p>　　DOM元素的数量很容易测试，只需键入Firebug的控制台：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.getElementsByTagName(<span class="string">'*'</span>).length;</span><br></pre></td></tr></table></figure><p>　　那到底有多少DOM元素才算少？检查具有良好标记的其他类似页面。例如<a href="http://www.yahoo.com/" target="_blank" rel="noopener">雅虎！主页</a>是一个非常繁忙的页面，仍然不到700个元素（HTML标记）。</p><h4 id="跨域拆分组件"><a href="#跨域拆分组件" class="headerlink" title="跨域拆分组件"></a>跨域拆分组件</h4><p>　　拆分组件允许您最大化并行下载。由于DNS查询惩罚，请确保您使用的域名不超过2-4个。例如，您可以托管HTML和动态内容，<code>www.example.org</code> 并在<code>static1.example.org</code>和之间拆分静态组件<code>static2.example.org</code></p><p>　　有关更多信息，请查看Tenni Theurer和Patty Chi的“ <a href="http://yuiblog.com/blog/2007/04/11/performance-research-part-4/" target="_blank" rel="noopener">在Carpool Lane中最大化并行下载</a> ”。</p><h4 id="最小化iframe数量"><a href="#最小化iframe数量" class="headerlink" title="最小化iframe数量"></a>最小化iframe数量</h4><p>　　iframe允许将HTML文档插入父文档中。了解iframe如何运作以便有效使用非常重要。</p><p><code>&lt;iframe&gt;</code> 优点：</p><ul><li>帮助缓慢的第三方内容，如徽章和广告</li><li>安全沙箱</li><li>并行下载脚本</li></ul><p><code>&lt;iframe&gt;</code> 缺点：</p><ul><li>即使空白也要花钱</li><li>阻止页面onload</li><li>非语义</li></ul><h4 id="尽量不用404s"><a href="#尽量不用404s" class="headerlink" title="尽量不用404s"></a>尽量不用404s</h4><p>　　HTTP请求很昂贵，因此发出HTTP请求并获得无用的响应（即404 Not Found）是完全没必要的，并且会在没有任何好处的情况下减慢用户体验。</p><p>　　有些网站有帮助404表示 ”你的意思是XXX？”，这对用户体验很有好处，但也浪费了服务器资源（比如数据库等）。特别糟糕的是当外部JavaScript的链接错误并且结果是404时。首先，此下载将阻止并行下载。接下来，浏览器可能会尝试解析404响应主体，就像它是JavaScript代码一样，试图找到可用的东西。</p><h4 id="减小Cookie大小"><a href="#减小Cookie大小" class="headerlink" title="减小Cookie大小"></a>减小Cookie大小</h4><p>　　HTTP cookie的使用有多种原因，例如身份验证和个性化。有关cookie的信息在Web服务器和浏览器之间的HTTP标头中进行交换。保持cookie的大小尽可能低是非常重要的，以尽量减少对用户响应时间的影响。</p><p>　　欲了解更多信息，请查看 Tenni Theurer和Patty Chi撰写的<a href="http://yuiblog.com/blog/2007/03/01/performance-research-part-3/" target="_blank" rel="noopener">“当Cookie崩溃时”</a>。这项研究的主要内容：</p><ul><li>消除不必要的cookie</li><li>保持cookie大小尽可能低，以尽量减少对用户响应时间的影响</li><li>请注意在适当的域级别设置cookie，以免其他子域受到影响</li><li>适当地设置过期日期。较早的Expires日期或者没有更早删除cookie，从而改善了用户响应时间</li></ul><h4 id="对组建使用cookie-free的域名"><a href="#对组建使用cookie-free的域名" class="headerlink" title="对组建使用cookie-free的域名"></a>对组建使用cookie-free的域名</h4><p>　　当浏览器发出静态图像请求并将cookie与请求一起发送时，服务器对这些cookie没有任何用处。所以他们只是没有充分理由创建网络流量。您应该确保使用无cookie请求请求静态组件。创建一个子域并在那里托管所有静态组件。</p><p>　　如果您的域名是<code>www.example.org</code>，您可以托管您的静态组件<code>static.example.org</code>。但是，如果您已经在顶级域上设置了cookie <code>example.org</code>而不是<code>www.example.org</code>，则所有请求都 <code>static.example.org</code>将包含这些cookie。在这种情况下，您可以购买一个全新的域，在那里托管您的静态组件，并保持此域无cookie。雅虎 用途<code>yimg.com</code>，YouTube使用<code>ytimg.com</code>，亚马逊使用<code>images-amazon.com</code>等。</p><p>　　在无cookie域上托管静态组件的另一个好处是，某些代理可能拒绝缓存使用cookie请求的组件。在相关说明中，如果您想知道是否应该使用<a href="https://example.org或https://www.example.org作为主页，请考虑cookie的影响。省略www会让您别无选择，只能写入cookie" target="_blank" rel="noopener">https://example.org或https://www.example.org作为主页，请考虑cookie的影响。省略www会让您别无选择，只能写入cookie</a> <code>*.example.org</code>，因此出于性能原因，最好使用www子域并将cookie写入该子域。</p><h4 id="最小化DOM的访问次数"><a href="#最小化DOM的访问次数" class="headerlink" title="最小化DOM的访问次数"></a>最小化DOM的访问次数</h4><p>​    使用JavaScript访问DOM元素的速度很慢，因此为了获得响应更快的页面，您应该：</p><ul><li>缓存对访问元素的引用</li><li>更新节点“离线”，然后将它们添加到树中</li><li>避免使用JavaScript修复布局</li></ul><p>　　有关更多信息，请查看 Julien Lecomte 的YUI影院的 <a href="http://yuiblog.com/blog/2007/12/20/video-lecomte/" target="_blank" rel="noopener">“高性能Ajax应用程序”</a>。</p><h4 id="开发巧妙的事件处理程序"><a href="#开发巧妙的事件处理程序" class="headerlink" title="开发巧妙的事件处理程序"></a>开发巧妙的事件处理程序</h4><p>　　有时页面感觉响应性较差，因为过多的事件处理程序附加到DOM树的不同元素，然后执行得太频繁。这就是为什么使用<em>事件委托</em>是一个很好的方法。如果a中有10个按钮<code>div</code>，则只将一个事件处理程序附加到div包装器，而不是每个按钮一个处理程序。事件冒出来，这样你就可以捕捉事件并找出它来自哪个按钮。</p><p>　　您也不需要等待onload事件以便开始使用DOM树执行某些操作。通常，您只需要在树中访问要访问的元素。您不必等待下载所有图像。<code>DOMContentLoaded</code>是您可能考虑使用的事件而不是onload，但在所有浏览器中都可用之前，您可以使用具有方法的<a href="https://developer.yahoo.com/yui/event/" target="_blank" rel="noopener">YUI事件</a>实用程序<code>onAvailable</code>。</p><p>　　有关更多信息，请查看 Julien Lecomte 的YUI影院的 <a href="http://yuiblog.com/blog/2007/12/20/video-lecomte/" target="_blank" rel="noopener">“高性能Ajax应用程序”</a>。</p><h4 id="优先选择使用-lt-link-gt-而非-import"><a href="#优先选择使用-lt-link-gt-而非-import" class="headerlink" title="优先选择使用&lt;link&gt;而非@import"></a>优先选择使用<code>&lt;link&gt;</code>而非<code>@import</code></h4><p>　　之前的最佳实践之一声明CSS应位于顶部以允许渐进式渲染。</p><p>　　在IE中，<code>@import</code>行为与<code>&lt;link&gt;</code>在页面底部使用相同，因此最好不要使用它。</p><h4 id="避免使用filters"><a href="#避免使用filters" class="headerlink" title="避免使用filters"></a>避免使用filters</h4><p>　　IE专有的<code>AlphaImageLoader</code>过滤器旨在解决IE版本&lt;7中的半透明真彩色PNG的问题。该过滤器的问题在于它在下载图像时阻止渲染并冻结浏览器。它还会增加内存消耗，并且每个元素应用，而不是每个图像，因此问题成倍增加。</p><p>　　最好的方法是<code>AlphaImageLoader</code>完全避免使用优雅降级的PNG8，这在IE中很好。如果你绝对需要<code>AlphaImageLoader</code>，使用下划线黑客<code>_filter</code>不会惩罚你的IE7 +用户。</p><h4 id="优化图片"><a href="#优化图片" class="headerlink" title="优化图片"></a>优化图片</h4><p>　　设计师完成为您的网页创建图像后，在将这些图像FTP到Web服务器之前，仍然可以尝试一些操作。</p><ul><li>您可以检查GIF并查看它们是否使用与图像中颜色数对应的调色板大小。使用<a href="http://www.imagemagick.org/" target="_blank" rel="noopener">imagemagick</a>很容易检查 </li><li><code>identify -verbose image.gif</code> </li><li>当你在调色板中看到使用4种颜色和256色“槽”的图像时，还有改进的余地。</li><li>尝试将GIF转换为PNG并查看是否存在保存。通常，有。由于浏览器的支持有限，开发人员经常对使用PNG犹豫不决，但现在已成为过去。唯一真正的问题是真彩色PNG中的alpha透明度，但是GIF也不是真彩色，也不支持变量透明度。所以GIF可以做任何事情，调色板PNG（PNG8）也可以做（动画除外）。这个简单的imagemagick命令导致完全安全的PNG：</li><li><code>convert image.gif image.png</code></li><li>我们所说的只是：给PiNG一个机会！”</li><li>在所有PNG上 运行<a href="http://pmt.sourceforge.net/pngcrush/" target="_blank" rel="noopener">pngcrush</a>（或任何其他PNG优化工具）。例： </li><li><code>pngcrush image.png -rem alla -reduce -brute result.png</code></li><li>在所有JPEG上运行jpegtran。此工具执行无损JPEG操作（如旋转），还可用于优化和删除图像中的注释和其他无用信息（如EXIF信息）。</li><li><code>jpegtran -copy none -optimize -perfect src.jpg dest.jpg</code></li></ul><h4 id="优化CSS-Sprites"><a href="#优化CSS-Sprites" class="headerlink" title="优化CSS Sprites　"></a>优化CSS Sprites　</h4><ul><li>将图像水平排列在精灵中而不是垂直排列通常会导致文件较小。</li><li>在精灵中组合相似的颜色可以帮助您保持较低的颜色数，理想情况下在256色以下，以适应PNG8。</li><li>“适合移动设备”并且不要在精灵中留下大的间隙。这不会影响文件大小，但需要较少的内存，以便用户代理将图像解压缩为像素图。100x100图像是1万像素，其中1000x1000是100万像素</li></ul><h4 id="不要在HTML中缩放图像"><a href="#不要在HTML中缩放图像" class="headerlink" title="不要在HTML中缩放图像"></a>不要在HTML中缩放图像</h4><p>　　不要使用比您需要的更大的图像，因为您可以在HTML中设置宽度和高度。如果您需要，</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">width</span>=<span class="string">"100"</span> <span class="attr">height</span>=<span class="string">"100"</span> <span class="attr">src</span>=<span class="string">"mycat.jpg"</span> <span class="attr">alt</span>=<span class="string">"My Cat"</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>　　那么您的图像（mycat.jpg）应该是100x100px而不是缩小的500x500px图像。</p><h4 id="减小favicon-ico的大小并缓存"><a href="#减小favicon-ico的大小并缓存" class="headerlink" title="减小favicon.ico的大小并缓存"></a>减小favicon.ico的大小并缓存</h4><p>　　favicon.ico是一个保留在服务器根目录中的映像。这是一个必要的邪恶，因为即使你不关心它，浏览器仍然会请求它，所以最好不要回复404 Not Found。此外，由于它位于同一台服务器上，因此每次请求时都会发送cookie。此图像也会干扰下载顺序，例如在IE中，当您在onload中请求额外组件时，将在这些额外组件之前下载favicon。</p><p>　　因此，为了减轻拥有favicon.ico的缺点，请确保：</p><ul><li>它很小，最好不到1K。</li><li>使用您感觉舒适的设置Expires标头（因为如果您决定更改它，则无法重命名）。您可以在将来几个月安全地设置Expires标头。您可以查看当前favicon.ico的上次修改日期，以做出明智的决定。</li></ul><p><a href="http://www.imagemagick.org/" target="_blank" rel="noopener">Imagemagick</a>可以帮助您创建小的favicons</p><h4 id="保持组件小于25K"><a href="#保持组件小于25K" class="headerlink" title="保持组件小于25K"></a>保持组件小于25K</h4><p>　　此限制与iPhone不会缓存大于25K的组件这一事实有关。请注意，这是<strong>未压缩的</strong>大小。这是缩小很重要的地方，因为单独使用gzip可能还不够。</p><p>​    欲了解更多信息，请查看Wayne Shea和Tenni Theurer的<a href="http://yuiblog.com/blog/2008/02/06/iphone-cacheability/" target="_blank" rel="noopener">性能研究，第5部分：iPhone可缓存性 - 让它坚持下去</a> 。</p><h4 id="将组件拆分到多个文档中"><a href="#将组件拆分到多个文档中" class="headerlink" title="将组件拆分到多个文档中"></a>将组件拆分到多个文档中</h4><p>　　将组件打包到多部分文档就像带有附件的电子邮件，它可以帮助您通过一个HTTP请求获取多个组件（请记住：HTTP请求很昂贵）。使用此技术时，首先检查用户代理是否支持它（iPhone不支持）。</p><h4 id="避免设置空图像的src"><a href="#避免设置空图像的src" class="headerlink" title="避免设置空图像的src"></a>避免设置空图像的src</h4><p>　　带有空字符串src属性的图像会出现多个预期。它以两种形式出现：</p><ol><li><p>HTML</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span> =<span class="string">""</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>JavaScript</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> img = <span class="keyword">new</span> Image();</span><br><span class="line">img.src =<span class="string">""</span>;</span><br></pre></td></tr></table></figure></li></ol><p>　　两种形式都会产生相同的效果：浏览器向您的服务器发出另一个请求</p><ul><li>Internet Explorer向页面所在的目录发出请求。</li><li>Safari和Chrome会向实际页面提出请求。</li><li>Firefox 3及更早版本的行为与Safari和Chrome相同，但3.5版解决了此问题<a href="https://bugzilla.mozilla.org/show_bug.cgi?id=444931" target="_blank" rel="noopener">[错误444931]</a>，不再发送请求。</li><li>遇到空图像时，Opera不执行任何操作。</li></ul><p>　　为什么这种行为不好？</p><ol><li>通过发送大量意外流量来削弱您的服务器，特别是对于每天获得数百万页面浏览量的页面。</li><li>废弃服务器计算周期生成永远不会被查看的页面。</li><li>可能会损坏用户数据。如果您通过cookie或其他方式跟踪请求中的状态，则可能会破坏数据。即使图像请求未返回图像，浏览器也会读取并接受所有标头，包括所有cookie。虽然其余的响应被丢弃，但可能已经造成了损害。</li></ol><p>　　此行为的根本原因是在浏览器中执行URI解析的方式。此行为在RFC 3986 - 统一资源标识符中定义。当遇到空字符串作为URI时，它被视为相对URI，并根据5.2节中定义的算法进行解析。这个具体的例子是一个空字符串，在5.4节中列出。Firefox，Safari和Chrome都按照规范正确解析空字符串，而Internet Explorer正在解析它，显然符合规范的早期版本RFC 2396 - 统一资源标识符（这已被RFC 3986废弃） 。从技术上讲，浏览器正在做他们应该做的事情来解析相对URI。问题是在这种情况下，</p><p>​    HTML5添加了img标记的src属性的描述，以指示浏览器不要在4.8.2节中提出额外的请求：</p><blockquote><p>src属性必须存在，并且必须包含引用非交互式（可选动画）图像资源的有效URL，该资源既不是分页也不是脚本。如果元素的基URI与文档的地址相同，则src属性的值不能是空字符串。</p></blockquote><p>　　希望浏览器将来不会出现这个问题。不幸的是，<code>&lt;script src =&quot;&quot;&gt;</code>和<code>&lt;link href =&quot;&quot;&gt;</code>没有这样的子句。也许还有时间进行调整以确保浏览器不会意外地实现此行为。</p><p>　　这条规则的灵感来自雅虎的JavaScript大师Nicolas C. Zakas。有关更多信息，请查看他的文章“ <a href="http://www.nczonline.net/blog/2009/11/30/empty-image-src-can-destroy-your-site/" target="_blank" rel="noopener">Empty image src can destroy your site</a> ”。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\Blog\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\Blog\assets\js\APlayer.m
      
    
    </summary>
    
    
      <category term="Web" scheme="https://www.knightboy.cn/Blog/tags/Web/"/>
    
  </entry>
  
  <entry>
    <title>给求职者的几点建议</title>
    <link href="https://www.knightboy.cn/Blog/2018/11/11/%E7%BB%99%E6%B1%82%E8%81%8C%E8%80%85%E7%9A%84%E5%87%A0%E7%82%B9%E5%BB%BA%E8%AE%AE/"/>
    <id>https://www.knightboy.cn/Blog/2018/11/11/给求职者的几点建议/</id>
    <published>2018-11-11T02:40:52.000Z</published>
    <updated>2018-11-19T11:18:05.695Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\Blog\assets\css\APlayer.min.css"><script src="\Blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">提前准备：</span><br><span class="line">准备好每一类问题，给自己一次审视自己，重新认识自我的机会。</span><br></pre></td></tr></table></figure><h3 id="自我介绍"><a href="#自我介绍" class="headerlink" title="自我介绍"></a>自我介绍</h3><h4 id="Question-1"><a href="#Question-1" class="headerlink" title="Question: 1"></a>Question: 1</h4><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="quote">&gt; 请你用三分钟时间做一个简单的自我介绍?</span></span><br></pre></td></tr></table></figure><p><strong>考察项： </strong><code>执行力</code> <code>理解力</code> <code>换位思考</code> <code>意识倾向</code></p><h6 id="1-执行力、理解力"><a href="#1-执行力、理解力" class="headerlink" title="1. 执行力、理解力"></a><span style="color: blue">1. 执行力、理解力</span></h6><p>​    是否听清面试官的要求，主要看应聘者是否有反应，要控制在面试官要求的时间范围内，如果没有把握，可以征询面试官是否要计时。</p><h6 id="2-换位思考"><a href="#2-换位思考" class="headerlink" title="2. 换位思考"></a><span style="color: blue">2. 换位思考</span></h6><p>​    不要对简历照念，复述型的自我介绍不好，好的自我介绍要回答我为什么应聘该岗位，我为什么适合该岗位。我喜欢要先说对公司和岗位的理解，我适合要说我的特长和能力。与公司和岗位要求恰恰是相符合的。</p><h6 id="4-意识倾向"><a href="#4-意识倾向" class="headerlink" title="4. 意识倾向"></a><span style="color: blue">4. 意识倾向</span></h6><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="quote">&gt; 答一：“我有很强的思维能力、学习能力、计划能力...”</span></span><br><span class="line"><span class="quote">&gt; 答二：“我有很强的沟通能力、协调能力、组织能力以及领导能力...”</span></span><br></pre></td></tr></table></figure><blockquote><p>回答提示:</p><p>不要照着简历念,企业想知道能否胜任工作.需要包括最强的技能,最深入研究的知识领域,个性中最积极的部分,做过的最成功的事,主要的成就等,这些都可以和学习无关,也可以和学习有关,但要突出积极的个性和做事的能力,说得合情合理HR才会相信.HR很注重一个人的礼貌,求职者要尊重面试官,在回答每个问题之后都说一句”谢谢”,有礼貌的求职者人人都喜欢.</p></blockquote><h3 id="网申开放题怎么答？"><a href="#网申开放题怎么答？" class="headerlink" title="网申开放题怎么答？"></a>网申开放题怎么答？</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="quote">&gt; 开放题侧重考察个人的合作能力和技巧，工作的抗压能力，是否有不利于工作和团队发展的一些问题等。</span></span><br><span class="line"><span class="quote">&gt; 开放性问题在正式找工作之前就应该去做，抽时间搞明白自己的优势和劣势。比如，我是个什么样的人，我在学校做了哪些牛叉的工作，取得了哪些突出的成就，这些成就体现了我的哪些气质，这种气质的我应该找什么类型的工作。即认清了自己，也能够轻松应对求职面试问题，岂不是一石二鸟，美滋滋~</span></span><br></pre></td></tr></table></figure><h4 id="Question-1-价值观"><a href="#Question-1-价值观" class="headerlink" title="Question 1: 价值观"></a>Question 1: 价值观</h4><blockquote><p> <b>你做的最成功/最失败的一件事是什么？让你感到最有成就感的是什么？让你感到最遗憾的一件事是什么？</b></p></blockquote><p>这类问题，HR主要考察的你的价值观导向，在你眼里什么是最重要；对你来说，什么才算成功。</p><p>我收集了几点通常的做法：</p><p><img src="your-value.jpg" alt="pic1"></p><h4 id="Question-2-未来规划"><a href="#Question-2-未来规划" class="headerlink" title="Question 2: 未来规划"></a>Question 2: 未来规划</h4><blockquote><p><b>谈谈你的职业规划？</b></p></blockquote><p>这类问题，HR希望挖掘你应聘的深层次动机，看你是否具有职业<strong>稳定性</strong>。</p><h4 id="Question-3-学习能力"><a href="#Question-3-学习能力" class="headerlink" title="Question 3: 学习能力"></a>Question 3: 学习能力</h4><blockquote><p><strong>谈谈你是怎样学习(前端 or 后端)的?</strong></p></blockquote><p>这类问题就谈你从多种渠道，全方位，立体式的挖掘你对某一领域的研究成果或方式，展现你的浓厚的兴趣和强烈的好奇心，回答越具体越好。</p><blockquote><p><b>请问你最近在看什么书？</b></p></blockquote><h4 id="Question-4-解决问题能力"><a href="#Question-4-解决问题能力" class="headerlink" title="Question 4: 解决问题能力"></a>Question 4: 解决问题能力</h4><blockquote><p><b>说说你曾经面对过哪些困难，你是如何解决的？举一个令你印象最深的一个。</b></p></blockquote><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="quote">&gt; 尽管HR问的是困难经历，但是HR在意的并不是结果，而是想了解应聘者在这次经历中学到的一些东西，吸取了什么教训，从而考察其学习能力和应变能力及抗压能力。在面试中类似的问题还有“你最自豪的一件事” “你在学习和工作中最难忘的一件事” “谈谈你的一次失败经历”等。</span></span><br></pre></td></tr></table></figure><p><span style="color:blue"><b>举例</b></span></p><p><strong>我:</strong> 我曾经作为某某活动的负责人{组织者、发起人等等}组织了某某活动{参加某某比赛实践项目}，期间我做了很多努力{比如}但是由于一些原因{自己的原因}，最终没能达到预期的效果。虽然结果令人遗憾，但是我从中认识到了不足，也积累了经验，汲取的教训，谈谈自己的收获。最后，我认为失败是在所难免的，有时候失败比成功更能促进人的进步，经过我的锻炼和学习，我相信如果再经历相关的实践工作，我一定会做的更好！</p><h4 id="Question-5-性格测验"><a href="#Question-5-性格测验" class="headerlink" title="Question 5: 性格测验"></a>Question 5: 性格测验</h4><blockquote><p><b>请问在你同学和老师眼中你分别是一个什么样的人？</b></p></blockquote><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="quote">&gt; 角色丰富的人，在同学眼中与在老师眼中的自己是不一样的。找准定位，角色丰富的人知道什么场景下自己就应该表现什么行为，见到什么人应该说什么话，会有比较良好的人际关系。而这一点，对于有些人很简单做的，而对于另一拨人则不容易，楼主恰恰属于后者。再描述一下自己在不同人眼中的共性，就更完美了，说明自己的换位思考能力比较强，能站在对方的立场，角色感比较强，不是一个没有原则，见风使舵，两面三刀的人。</span></span><br></pre></td></tr></table></figure><h4 id="Question5-思维独立"><a href="#Question5-思维独立" class="headerlink" title="Question5: 思维独立"></a>Question5: 思维独立</h4><blockquote><p><strong>你最崇拜或你最敬仰的人是谁？</strong></p></blockquote><h4 id="Question6-自我接纳"><a href="#Question6-自我接纳" class="headerlink" title="Question6: 自我接纳"></a>Question6: 自我接纳</h4><blockquote><p><strong>在上一份实习中，你收获了什么，学到了什么？</strong></p></blockquote><h4 id="Question7-执行力、自我明示性"><a href="#Question7-执行力、自我明示性" class="headerlink" title="Question7: 执行力、自我明示性"></a>Question7: 执行力、自我明示性</h4><blockquote><p><strong>请介绍一下你的优缺点？</strong></p></blockquote><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="quote">&gt; 好的回答：我个人理解的优缺点不是绝对的，都需要背景和假设前提来衬托的，我来说说我的特点吧，我做事认真，在出错率低方面是个优点，在效率方面是个缺点，我已经意识到自己的这个问题了，正在努力在要求不是那么细致的工作上提高效率。企业喜欢求职者从自己的优点说起,中间加一些小缺点,最后把问题转回到优点上,突出优点部分,企业喜欢聪明的求职者. 侧重个性方面的优点: 沉着冷静,条理清楚,立场坚定,顽强向上,乐于助人和关心他人,适应能力和幽默感,乐观和友爱等,结合自己的亲身经历,举例描述自己的优点.</span></span><br></pre></td></tr></table></figure><blockquote><p><strong>你对加班的看法？</strong><br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="quote">&gt; 实际上好多公司问这个问题,是想测试你是否愿意为公司奉献. 你可以这样回答: 如果工作需要,我会义不容辞加班,我现在单身,没有家庭负担,可以全身心的投入工作中.但同时我也会提高工作效率,减少不必要的加班.</span></span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p><strong>你对跳槽的看法?</strong></p></blockquote><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="quote">&gt; 正常的"跳槽"能促进人才的合理流动,应该支持.</span></span><br><span class="line"><span class="quote">&gt; 频繁的跳槽对单位和个人双方都不利,应该反对.</span></span><br></pre></td></tr></table></figure><blockquote><p><strong>工作中难以和同事,上司相处,你该怎么办?</strong></p></blockquote><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="quote">&gt; 我会服从领导的指挥,配合好同事的工作.</span></span><br><span class="line"><span class="quote">&gt; 我会从自身找原因,仔细分析是不是自己的工作做的不好让领导不满意,同事看不惯.还要看看为人处世方面做的好不好,如果是自己的原因,我会努力改正.</span></span><br><span class="line"><span class="quote">&gt; 如果找不到原因,我会找合适的机会跟他们沟通,请他们指出我的不足,有问题就及时改正.</span></span><br><span class="line"><span class="quote">&gt; 作为优秀的员工,应该时刻以大局为重,即使在一段时间内,领导和同事对我不理解,我也会做好本职工作,虚心向他们学习,我相信,他们会看见我的努力,总有一天会对我微笑的.</span></span><br></pre></td></tr></table></figure><blockquote><p><strong>你如何对待别人的批评?</strong></p></blockquote><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="quote">&gt; 我会接受建设性的批评</span></span><br><span class="line"><span class="quote">&gt; 我会等大家冷静下来再讨论.</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\Blog\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\Blog\assets\js\APlayer.m
      
    
    </summary>
    
      <category term="求职" scheme="https://www.knightboy.cn/Blog/categories/%E6%B1%82%E8%81%8C/"/>
    
    
      <category term="应聘" scheme="https://www.knightboy.cn/Blog/tags/%E5%BA%94%E8%81%98/"/>
    
      <category term="经验" scheme="https://www.knightboy.cn/Blog/tags/%E7%BB%8F%E9%AA%8C/"/>
    
      <category term="职场" scheme="https://www.knightboy.cn/Blog/tags/%E8%81%8C%E5%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>post_name</title>
    <link href="https://www.knightboy.cn/Blog/2018/11/10/post-name/"/>
    <id>https://www.knightboy.cn/Blog/2018/11/10/post-name/</id>
    <published>2018-11-10T12:33:42.000Z</published>
    <updated>2018-11-14T14:18:06.869Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\Blog\assets\css\APlayer.min.css"><script src="\Blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="图片相对地址测试"><a href="#图片相对地址测试" class="headerlink" title="图片相对地址测试"></a>图片相对地址测试</h3><p><img src="shrink-btn.jpg" alt="test1"></p><h4 id="音乐加载"><a href="#音乐加载" class="headerlink" title="音乐加载"></a>音乐加载</h4>        <div id="aplayer-cKLivamW" class="aplayer aplayer-tag-marker" style="margin-bottom: 20px;">            <pre class="aplayer-lrc-content"></pre>        </div>        <script>          var ap = new APlayer({            element: document.getElementById("aplayer-cKLivamW"),            narrow: false,            autoplay: false,            showlrc: false,            music: {              title: "Hotel California",              author: "Eagles",              url: "Hotel California.mp3",              pic: "/Blog/2018/11/10/post-name/Hotel%20California.jpg",              lrc: ""            }          });          window.aplayers || (window.aplayers = []);          window.aplayers.push(ap);        </script><h4 id="无宽高设置"><a href="#无宽高设置" class="headerlink" title="无宽高设置"></a>无宽高设置</h4><img src="https://raw.githubusercontent.com/Knight-boy/QQone/gh-pages/public/images/Owner.jpg" title="测试图片"><h4 id="宽高设置"><a href="#宽高设置" class="headerlink" title="宽高设置"></a>宽高设置</h4><img src="https://theme-next.iissnan.com/uploads/tags/full-image.jpg" width="300" height="200" title="测试图片"><h4 id="突破容器限制"><a href="#突破容器限制" class="headerlink" title="突破容器限制"></a>突破容器限制</h4><p><code>HTML方式: 直接在 Markdown 文件中编写 HTML 来调用</code><br><code>其中 class=&quot;full-image&quot; 是必须的</code><br><img src="https://theme-next.iissnan.com/uploads/tags/full-image.jpg" class="full-image"></p><p><code>标签 方式，要求版本在0.4.5或以上</code><br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">span</span> <span class="attr">itemprop</span>=<span class="string">"image"</span> <span class="attr">itemscope</span> <span class="attr">itemtype</span>=<span class="string">"http://schema.org/ImageObject"</span>&gt;</span></span><span class="xml"><span class="tag">&lt;<span class="name">img</span> <span class="attr">itemprop</span>=<span class="string">"url image"</span> <span class="attr">src</span>=<span class="string">"https://theme-next.iissnan.com/uploads/tags/full-image.jpg"</span> <span class="attr">class</span>=<span class="string">"full-image"</span> <span class="attr">alt</span>=<span class="string">"alt"</span> <span class="attr">title</span>=<span class="string">"title"</span> /&gt;</span></span><span class="xml"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">itemprop</span>=<span class="string">"width"</span> <span class="attr">content</span>=<span class="string">"auto"</span>&gt;</span></span><span class="xml"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">itemprop</span>=<span class="string">"height"</span> <span class="attr">content</span>=<span class="string">"auto"</span>&gt;</span></span><span class="xml"><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br></pre></td></tr></table></figure></p><span itemprop="image" itemscope="" itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="https://theme-next.iissnan.com/uploads/tags/full-image.jpg" class="full-image" alt="alt" title="title"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span><p><code>fi别名</code><br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">span</span> <span class="attr">itemprop</span>=<span class="string">"image"</span> <span class="attr">itemscope</span> <span class="attr">itemtype</span>=<span class="string">"http://schema.org/ImageObject"</span>&gt;</span></span><span class="xml"><span class="tag">&lt;<span class="name">img</span> <span class="attr">itemprop</span>=<span class="string">"url image"</span> <span class="attr">src</span>=<span class="string">"https://theme-next.iissnan.com/uploads/tags/full-image.jpg"</span> <span class="attr">class</span>=<span class="string">"full-image"</span> <span class="attr">alt</span>=<span class="string">"alt"</span> <span class="attr">title</span>=<span class="string">"title"</span> /&gt;</span></span><span class="xml"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">itemprop</span>=<span class="string">"width"</span> <span class="attr">content</span>=<span class="string">"auto"</span>&gt;</span></span><span class="xml"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">itemprop</span>=<span class="string">"height"</span> <span class="attr">content</span>=<span class="string">"auto"</span>&gt;</span></span><span class="xml"><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br></pre></td></tr></table></figure></p><span itemprop="image" itemscope="" itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="https://theme-next.iissnan.com/uploads/tags/full-image.jpg" class="full-image" alt="alt" title="title"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\Blog\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\Blog\assets\js\APlayer.m
      
    
    </summary>
    
    
      <category term="test" scheme="https://www.knightboy.cn/Blog/tags/test/"/>
    
  </entry>
  
  <entry>
    <title>Something Wrong</title>
    <link href="https://www.knightboy.cn/Blog/2018/11/10/Something-Wrong/"/>
    <id>https://www.knightboy.cn/Blog/2018/11/10/Something-Wrong/</id>
    <published>2018-11-10T11:54:22.000Z</published>
    <updated>2018-11-10T13:36:28.956Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\Blog\assets\css\APlayer.min.css"><script src="\Blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="Github-子项目"><a href="#Github-子项目" class="headerlink" title="Github 子项目"></a>Github 子项目</h3><p>如下图所示：</p><p>​    当通过标题展开文章内容时，root地址将会重复加载，使url链接失效</p><p><img src="/Blog/images/title-here.jpg" alt="title"></p><center><b>click title</b></center><p><img src="/Blog/images/title-link.jpg" alt="dfd"></p><center><b>after…</b></center><p>​    当通过下方缩放按钮获取整篇文章内容时，链接是有效的。</p><p><img src="/Blog/images/shrink-btn.jpg" alt="hgth"></p><center><b>more than…</b></center><h3 id="按照hexo-官方文档中如下设置"><a href="#按照hexo-官方文档中如下设置" class="headerlink" title="按照hexo 官方文档中如下设置"></a>按照hexo 官方文档中如下设置</h3><p>在命令$ hexo g 生成的文档中，最终被解析出的静态文档index.html中的链接中又重复添加了子文件夹中的/Blog</p><p><img src="/Blog/images/modifysub.jpg" alt="fgg"></p><center><b>设置情况</b></center><p><img src="/Blog/images/found.jpg" alt="ffrg"></p><center><b>解析情况</b></center>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\Blog\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\Blog\assets\js\APlayer.m
      
    
    </summary>
    
      <category term="hexo" scheme="https://www.knightboy.cn/Blog/categories/hexo/"/>
    
    
      <category term="hexo" scheme="https://www.knightboy.cn/Blog/tags/hexo/"/>
    
      <category term="site" scheme="https://www.knightboy.cn/Blog/tags/site/"/>
    
      <category term="subdirectory" scheme="https://www.knightboy.cn/Blog/tags/subdirectory/"/>
    
      <category term="title" scheme="https://www.knightboy.cn/Blog/tags/title/"/>
    
      <category term="problem" scheme="https://www.knightboy.cn/Blog/tags/problem/"/>
    
  </entry>
  
  <entry>
    <title>Makerdown Syntax</title>
    <link href="https://www.knightboy.cn/Blog/2018/11/09/Makerdown-Syntax/"/>
    <id>https://www.knightboy.cn/Blog/2018/11/09/Makerdown-Syntax/</id>
    <published>2018-11-09T07:26:49.000Z</published>
    <updated>2018-11-12T03:21:08.291Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\Blog\assets\css\APlayer.min.css"><script src="\Blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="HTML-Elements"><a href="#HTML-Elements" class="headerlink" title="HTML Elements"></a>HTML Elements</h2><p>Below is just about everything you’ll need to style in the theme. Check the source code to see the many embedded elements within paragraphs.</p><h1 id="Heading-1"><a href="#Heading-1" class="headerlink" title="Heading 1"></a>Heading 1</h1><h2 id="Heading-2"><a href="#Heading-2" class="headerlink" title="Heading 2"></a>Heading 2</h2><h3 id="Heading-3"><a href="#Heading-3" class="headerlink" title="Heading 3"></a>Heading 3</h3><h4 id="Heading-4"><a href="#Heading-4" class="headerlink" title="Heading 4"></a>Heading 4</h4><h5 id="Heading-5"><a href="#Heading-5" class="headerlink" title="Heading 5"></a>Heading 5</h5><h6 id="Heading-6"><a href="#Heading-6" class="headerlink" title="Heading 6"></a>Heading 6</h6><h3 id="Body-text"><a href="#Body-text" class="headerlink" title="Body text"></a>Body text</h3><p>Lorem ipsum dolor sit amet, test link adipiscing elit. <strong>This is strong</strong>. Nullam dignissim convallis est. Quisque aliquam.</p><p><img src="https://raw.githubusercontent.com/Knight-boy/QQone/gh-pages/public/images/Owner.jpg" alt="Smithsonian Image"></p><p><em>This is emphasized</em>. Donec faucibus. Nunc iaculis suscipit dui. 5<sup>3</sup> = 125. Water is H<sub>2</sub>O. Nam sit amet sem. Aliquam libero nisi, imperdiet at, tincidunt nec, gravida vehicula, nisl. The New York Times (That’s a citation). Underline.Maecenas ornare tortor. Donec sed tellus eget sapien fringilla nonummy. Mauris a ante. Suspendisse quam sem, consequat at, commodo vitae, feugiat in, nunc. Morbi imperdiet augue quis tellus.</p><p>HTML and CSS are our tools. Mauris a ante. Suspendisse quam sem, consequat at, commodo vitae, feugiat in, nunc. Morbi imperdiet augue quis tellus. Praesent mattis, massa quis luctus fermentum, turpis mi volutpat justo, eu volutpat enim diam eget metus.</p><h3 id="Blockquotes"><a href="#Blockquotes" class="headerlink" title="Blockquotes"></a>Blockquotes</h3><blockquote><p>Lorem ipsum dolor sit amet, test link adipiscing elit. Nullam dignissim convallis est. Quisque aliquam.</p></blockquote><h2 id="List-Types"><a href="#List-Types" class="headerlink" title="List Types"></a>List Types</h2><h3 id="Ordered-Lists"><a href="#Ordered-Lists" class="headerlink" title="Ordered Lists"></a>Ordered Lists</h3><ol><li>Item one<ol><li>sub item one</li><li>sub item two</li><li>sub item three</li></ol></li><li>Item two</li></ol><h3 id="Unordered-Lists"><a href="#Unordered-Lists" class="headerlink" title="Unordered Lists"></a>Unordered Lists</h3><ul><li>Item one</li><li>Item two</li><li>Item three</li></ul><h2 id="Tables"><a href="#Tables" class="headerlink" title="Tables"></a>Tables</h2><table><thead><tr><th style="text-align:left">Header1</th><th style="text-align:center">Header2</th><th style="text-align:right">Header3</th></tr></thead><tbody><tr><td style="text-align:left">cell1</td><td style="text-align:center">cell2</td><td style="text-align:right">cell3</td></tr><tr><td style="text-align:left">cell4</td><td style="text-align:center">cell5</td><td style="text-align:right">cell6</td></tr><tr><td style="text-align:left">—– </td></tr><tr><td style="text-align:left">cell1</td><td style="text-align:center">cell2</td><td style="text-align:right">cell3</td></tr><tr><td style="text-align:left">cell4</td><td style="text-align:center">cell5</td><td style="text-align:right">cell6</td></tr><tr><td style="text-align:left">===== </td></tr><tr><td style="text-align:left">Foot1</td><td style="text-align:center">Foot2</td><td style="text-align:right">Foot3</td></tr></tbody></table><h2 id="Code-Snippets"><a href="#Code-Snippets" class="headerlink" title="Code Snippets"></a>Code Snippets</h2><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#container</span> &#123;</span><br><span class="line">  <span class="attribute">float</span>: left;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0</span> -<span class="number">240px</span> <span class="number">0</span> <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Buttons"><a href="#Buttons" class="headerlink" title="Buttons"></a>Buttons</h2><p>Make any link standout more when applying the <code>.btn</code> class.</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#"</span> <span class="attr">class</span>=<span class="string">"bs-callout bs-callout-warning"</span>&gt;</span>Success Button<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><div markdown="0"><a href="#" class="btn btn-success">Success Button</a></div><br><div markdown="0"><a href="#" class="btn btn-warning">Warning Button</a></div><br><div markdown="0"><a href="#" class="btn btn-danger">Danger Button</a></div><br><div markdown="0"><a href="#" class="btn btn-info">Info Button</a></div><h2 id="KBD"><a href="#KBD" class="headerlink" title="KBD"></a>KBD</h2><p>You can also use <code>&lt;kbd&gt;</code> tag for keyboard buttons.</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">kbd</span>&gt;</span>W<span class="tag">&lt;/<span class="name">kbd</span>&gt;</span><span class="tag">&lt;<span class="name">kbd</span>&gt;</span>A<span class="tag">&lt;/<span class="name">kbd</span>&gt;</span><span class="tag">&lt;<span class="name">kbd</span>&gt;</span>S<span class="tag">&lt;/<span class="name">kbd</span>&gt;</span><span class="tag">&lt;<span class="name">kbd</span>&gt;</span>D<span class="tag">&lt;/<span class="name">kbd</span>&gt;</span></span><br></pre></td></tr></table></figure><p>Press <kbd>W</kbd><kbd>A</kbd><kbd>S</kbd><kbd>D</kbd> to move your car. <strong>Midtown Maddness!!</strong></p><h2 id="Notices"><a href="#Notices" class="headerlink" title="Notices"></a>Notices</h2><p><strong>Watch out!</strong> You can also add notices by appending <code>{: .notice}</code> to a paragraph.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\Blog\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\Blog\assets\js\APlayer.m
      
    
    </summary>
    
      <category term="hexo" scheme="https://www.knightboy.cn/Blog/categories/hexo/"/>
    
    
      <category term="makerdown" scheme="https://www.knightboy.cn/Blog/tags/makerdown/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://www.knightboy.cn/Blog/2018/11/09/hello-world/"/>
    <id>https://www.knightboy.cn/Blog/2018/11/09/hello-world/</id>
    <published>2018-11-09T04:20:27.871Z</published>
    <updated>2018-11-10T13:21:14.240Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\Blog\assets\css\APlayer.min.css"><script src="\Blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\Blog\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\Blog\assets\js\APlayer.m
      
    
    </summary>
    
      <category term="hexo" scheme="https://www.knightboy.cn/Blog/categories/hexo/"/>
    
    
      <category term="hexo" scheme="https://www.knightboy.cn/Blog/tags/hexo/"/>
    
  </entry>
  
</feed>
